<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="USYD3027,Greedy,">










<meta name="description" content="CLRS: 算法导论 Week3 贪心定义: A greedy algorithm always makes the choice that looks best at the moment. That is, it makes a locally optimal choice in the hope that this choice will lead to a globally opti">
<meta name="keywords" content="USYD3027,Greedy">
<meta property="og:type" content="article">
<meta property="og:title" content="Greedy Intro">
<meta property="og:url" content="http://yoursite.com/2019/03/16/3027-week3/index.html">
<meta property="og:site_name" content="Shirley&#39;s blog">
<meta property="og:description" content="CLRS: 算法导论 Week3 贪心定义: A greedy algorithm always makes the choice that looks best at the moment. That is, it makes a locally optimal choice in the hope that this choice will lead to a globally opti">
<meta property="og:locale" content="default">
<meta property="og:updated_time" content="2019-03-16T06:36:27.537Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Greedy Intro">
<meta name="twitter:description" content="CLRS: 算法导论 Week3 贪心定义: A greedy algorithm always makes the choice that looks best at the moment. That is, it makes a locally optimal choice in the hope that this choice will lead to a globally opti">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2019/03/16/3027-week3/">





  <title>Greedy Intro | Shirley's blog</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Shirley's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">代码小白的学习笔记</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/16/3027-week3/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Shirley Hou">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Shirley's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Greedy Intro</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-03-16T10:31:56+11:00">
                2019-03-16
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/USYD/" itemprop="url" rel="index">
                    <span itemprop="name">USYD</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/USYD/CLRS/" itemprop="url" rel="index">
                    <span itemprop="name">CLRS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>CLRS: 算法导论</p>
<h1 id="Week3-贪心"><a href="#Week3-贪心" class="headerlink" title="Week3 贪心"></a>Week3 贪心</h1><p><br>定义: A greedy algorithm <strong>always makes the choice that looks best at the moment.</strong> That is, it makes a locally optimal choice in the hope that this choice will lead to a globally optimal solution.</p>
<p>举一个pramp上遇到的经典例子. 如果有一颗普通的二叉树, 每一条路径都有一个正的cost, 求从root到leaf最小的cost是多少.<br>比如:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">             R                  ----Root</span><br><span class="line">        (2)     (1)     </span><br><span class="line">      r.l        R.r            ----Children</span><br><span class="line">   (3)   (1)    (0)   null    </span><br><span class="line">R.l.l   R.l.r   R.r.l           ----GrandChildren</span><br></pre></td></tr></table></figure></p>
<p>对于这道题, 我们从leaf开始返回自己的cost, 在每一个parent层(有点像商科里概率树里的decision vertex)做决策: 目前累积下来的left child tree和right child tree哪个更小就选哪个加上自己继续往上传递. 这样每一层选下来的结果(locally)在root这一层(globally也一定是最小的. </p>
<p>学校lecture里cover 4个经典问题.</p>
<ul>
<li>Interval Scheduling Problem</li>
<li>Minimizing Lateness</li>
<li>Minimum Spanning Tree</li>
<li>Shortest Path (Dijkstra)</li>
</ul>
<h2 id="证明Greedy的三种方法"><a href="#证明Greedy的三种方法" class="headerlink" title="证明Greedy的三种方法"></a>证明Greedy的三种方法</h2><ul>
<li><strong>Exchange Argument</strong> (最好, 推荐在asm1里用)</li>
</ul>
<p>Transform any solution to the one found by the greedy algorithm without hurting its quality.</p>
<ul>
<li><strong>Greedy algorithm stays ahead</strong></li>
</ul>
<p>Show after each step of the greedy algorithm its solution is at least as good as other algorithms.</p>
<ul>
<li><strong>Structural</strong></li>
</ul>
<p>Discover a bound asserting that every possible solution must have a certain value and your algorithm always achieves this bound.</p>
<h2 id="Interval-Scheduling-Proble-Activity-Selection-Problem"><a href="#Interval-Scheduling-Proble-Activity-Selection-Problem" class="headerlink" title="Interval Scheduling Proble/(Activity Selection Problem)"></a>Interval Scheduling Proble/(Activity Selection Problem)</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义:"></a>定义:</h3><p>有一组活动 <code>S = {a1, a2, .. an}</code>. 每一个活动有<code>[s, f)</code>两个时间代表开始和结束.<br>如果有两个活动, <code>a_i</code>和<code>a_j</code>, 它们compatible的话, 就说明它们开始和结束的时间没有任何的重叠 <code>[s_i, f_i)</code> does not overlap with <code>[s_j, f_j)</code>. 如果两个活动重叠的话我们就不能都选. 我们希望给定一段时间, 能够从<code>S</code>中选择数量最多的活动.</p>
<h3 id="一句话记住怎么做"><a href="#一句话记住怎么做" class="headerlink" title="一句话记住怎么做:"></a>一句话记住怎么做:</h3><p>Keep choosing the activity that finishes first, keep only the activities compatible with this activity, and repeat until no activities remain.</p>
<h3 id="如果要证明"><a href="#如果要证明" class="headerlink" title="如果要证明..:"></a>如果要证明..:</h3><ul>
<li>定义</li>
</ul>
<p>for any subproblem <code>S_k</code>, let <code>a_m</code> be the earliest finish time one in <code>S_k</code>, then <code>a_m</code> is included in the optimal solution for <code>S_k</code>.</p>
<ul>
<li>什么是subproblem? </li>
</ul>
<p>subproblem就是做数学归纳法里必须的一步, 如果大家还记得, 我们一般先证明1, 再证明k, 推到k+1. 可以理解为这个第k步.</p>
<p>在greedy里, 如果subproblem(第k步)有一个最优解, 那这个最优解也一定包含在k+1步里.</p>
<h3 id="证明"><a href="#证明" class="headerlink" title="证明:"></a>证明:</h3><p>假设S这个subproblem <code>S_k</code> 有两个解<code>A_k</code>, <code>A_k&#39;</code>. 然后我们的活动集<code>S</code>里里有两个活动, <code>a_j</code>和<code>a_m</code>. 但是<code>a_m</code>是结束时间最早的那个, 有 <code>f_m &lt;= f_j</code>.<br>我们设 <code>A_k</code> 里有<code>a_j</code>但是没有<code>a_m</code>, 也就是不包括结束时间最早的那个.</p>
<p>另外, 我们使得(我们要证明的真正的最优解)<code>A_k&#39; = A_k - a_j + a_m</code>作为一个含有<code>a_m</code>但不含有<code>a_j</code>的解. </p>
<p>—梳理一下, <code>A_k</code>和<code>A_k&#39;</code>目前唯一的区别就是,<code>A_k</code>里有<code>a_j</code>而没有<code>a_m</code>.<br>我们要证明<code>A_k&#39;</code>不比<code>A_k</code>差, 甚至要更好. 以此证明我们一定要包含<code>a_m.</code></p>
<p>首先, <code>A_k&#39; = A_k- a_j + a_m</code>一增一减, <code>A_k&#39;</code>的大小还是和<code>A_k</code>的大小一样. <br>因为为了符合题意, 最优解里的活动已经不会overlap each other, 再加上<code>f_m &lt; f_j</code>, 所以所以这样换下来, 还是不会有overlap的情况, 并不会对<code>a_m</code>后面的事件产生影响.</p>
<p>既然用<code>a_m</code>换掉<code>a_j</code>并不会影响结果的大小, 说明我们可以确定<code>a_m</code>一定会在最优解里了.</p>
<h2 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">sort S by finish time. </span><br><span class="line"></span><br><span class="line">n = S.length</span><br><span class="line">A = &#123;S[0]&#125;</span><br><span class="line">k = 1</span><br><span class="line">for m = 2 to n:</span><br><span class="line">    if S[m].start&gt;=S[k].finish:</span><br><span class="line">        A.add(S[m])</span><br><span class="line">        k = m</span><br><span class="line">return A</span><br></pre></td></tr></table></figure>
<h2 id="python-实现"><a href="#python-实现" class="headerlink" title="python 实现"></a>python 实现</h2><p>(lecture里的例子)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Activity</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, start, finish)</span>:</span></span><br><span class="line">        self.start = start</span><br><span class="line">        self.finish = finish</span><br><span class="line">    </span><br><span class="line">S = [</span><br><span class="line">    Activity(<span class="number">0</span>,<span class="number">6</span>),</span><br><span class="line">    Activity(<span class="number">1</span>,<span class="number">4</span>),</span><br><span class="line">    Activity(<span class="number">3</span>,<span class="number">5</span>),</span><br><span class="line">    Activity(<span class="number">3</span>,<span class="number">8</span>),</span><br><span class="line">    Activity(<span class="number">4</span>,<span class="number">7</span>),</span><br><span class="line">    Activity(<span class="number">5</span>,<span class="number">9</span>),</span><br><span class="line">    Activity(<span class="number">6</span>,<span class="number">10</span>),</span><br><span class="line">    Activity(<span class="number">8</span>,<span class="number">11</span>),</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">intervalScheduling</span><span class="params">(S, start_time, finish_time)</span>:</span></span><br><span class="line"></span><br><span class="line">    S.sort(key= <span class="keyword">lambda</span> x : x.finish)</span><br><span class="line">    k = <span class="number">0</span></span><br><span class="line">    n = len(S)</span><br><span class="line">    <span class="keyword">while</span>(k&lt;len(S)):</span><br><span class="line">        s = S[k]</span><br><span class="line">        <span class="keyword">if</span> s.start&gt;start_time:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        k+=<span class="number">1</span></span><br><span class="line"></span><br><span class="line">    A=[S[k]]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> m <span class="keyword">in</span> range(k+<span class="number">1</span>, n):</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> S[m].start&gt;=S[k].finish <span class="keyword">and</span> S[m].finish&lt;=finish_time:</span><br><span class="line">            A.append(S[m])</span><br><span class="line">            k = m</span><br><span class="line">    <span class="keyword">return</span> A</span><br><span class="line"></span><br><span class="line">solution = intervalScheduling(S, <span class="number">0</span>, <span class="number">11</span>)</span><br><span class="line">print(len(solution))</span><br><span class="line"><span class="keyword">for</span> s <span class="keyword">in</span> solution:</span><br><span class="line">    print(s.start, s.finish)</span><br></pre></td></tr></table></figure>
<h2 id="Minimize-Lateness"><a href="#Minimize-Lateness" class="headerlink" title="Minimize Lateness"></a>Minimize Lateness</h2><p>这个问题usyd的证明省略了非常多的前后知识, 如果要严格的证明需要很长的篇幅. 可以直接参考lecture slides里的内容.<br>与slides相同但阅读起来更完善的的资料:<a href="https://ocw.tudelft.nl/wp-content/uploads/Algoritmiek_Scheduling_to_Minimize_Maximum_Lateness.pdf" target="_blank" rel="noopener">TU Delft对于这个问题的讲义</a></p>
<h3 id="一句话记住怎么做-1"><a href="#一句话记住怎么做-1" class="headerlink" title="一句话记住怎么做:"></a>一句话记住怎么做:</h3><p>直接按每一个task的deadline排列, 不要有 <strong>idle time</strong>(什么都不做的空白时间).</p>
<ol>
<li>首先, 显然因为每项任务没有开始时间的要求, optimal solution一定是没有idle time的. idle time的意思是闲着什么都不做的时间.</li>
<li><strong>inversion</strong>的意思是有两个task <code>i</code>和<code>k</code>, <code>d_i (deadline of i) &lt; d_k (deadline of k)</code>, 但是<code>k</code>却被放在了<code>i</code>的前面.</li>
<li>Greedy的方法是先去完成deadline比较小的task, 所以没有inversion.</li>
</ol>
<ul>
<li>问题: </li>
</ul>
<p>What is the difference in maximum lateness between two schedules without inversions and without idle time?</p>
<ul>
<li>回答: 没有区别. </li>
</ul>
<p>假如所有的task的deadline都是确定的, 而且没有inversion, 那排列的方法就是唯一的, 最后的lateness也是唯一的.<br>只有当, 如果有两个task <code>i</code>和 <code>j</code>它们的deadline相等的时候, 无论<code>i</code>放前面还是<code>j</code>放前面, lateness都一样.</p>
<ol start="4">
<li>如果一个schedule里没有idle, 而且只有一对inversion, 那么这对inversion的task是连续的. </li>
</ol>
<p>问题: 如果交换一对有inversion的task(原本是<code>i, j, d_i &lt; d_j</code>, 但<code>i</code>放在了<code>j</code>后面), 会对lateness造成什么影响?</p>
<ul>
<li>subproblem一样, 总的finish时间是一样的. finish时间要么是f_i要么是f_j.</li>
<li>结论:如果交换回来让, 让<code>i</code>回到<code>j</code>前面, 会严格的减少或者保持现有的lateness.</li>
</ul>
<p>如何用Exchange Argument?<br>(slides里的证明)</p>
<h2 id="Minimum-Spanning-Tree-MST"><a href="#Minimum-Spanning-Tree-MST" class="headerlink" title="Minimum Spanning Tree (MST)"></a>Minimum Spanning Tree (MST)</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>Tree, spanning tree 和minimum spanning tree的定义层层递进</p>
<ul>
<li><p><strong>Tree</strong>: 没有cycle的graph</p>
</li>
<li><p><strong>Spanning Tree</strong>: 没有cycle而且连接graph里所有vertices的tree.</p>
</li>
<li><p><strong>Minimum Spanning Tree</strong>: 所有可能的spanning tree里edge weight之和最小的spanning tree.</p>
</li>
</ul>
<h3 id="一句话记住怎么做-2"><a href="#一句话记住怎么做-2" class="headerlink" title="一句话记住怎么做:"></a>一句话记住怎么做:</h3><ul>
<li><strong>如何找MST? 一个general的方法</strong></li>
</ul>
<p>把所有edge按照weight从小到大来排列.<br>我们知道, 一个有V个vertex的tree里最多只能有V-1个edge,否则就会有cycle, 不再是tree.</p>
<p>开一个空集<code>A</code>来存MST里所需要的edge.</p>
<p>从小到大来往<code>A</code>里加edge, 条件是加进来edge以后需要依旧要保持tree的特性, 不能产生cycle.</p>
<p>(这一段的证明需参考CLRS)</p>
<ul>
<li>如何证明我们这样做是对的?</li>
</ul>
<p>(Greedy stays ahead方法)</p>
<ol>
<li>Invariant: Prior to each iteration, A is a subset of some minimum spanning tree</li>
<li>Start from empty set. Empty set is certainly a subset of solution.</li>
<li>During each iteration, we make sure the edge (u,v) added does not hurting the invariant that A is still a tree. (之后我会解释为什么prim和kruskal的方法可以make sure这一点)</li>
<li>And since we sorted the edge by weight, the edge (u,v) adds smallest weight to the set A, so A’s total weight is minimized.</li>
<li>Therefore invariant still holds after we add edge (u,v)</li>
</ol>
<h3 id="Prim的方法"><a href="#Prim的方法" class="headerlink" title="Prim的方法"></a>Prim的方法</h3><p>选定一个随意的vertex, 记为set <code>V = {n_0}</code></p>
<p>从这个vertex有的edge里找一个weight最小的edge扩展出去, 把这个edge另一端的vertex加进V里来.</p>
<p>当前 <code>V = {n_0, n_1}</code>.从这两个vertex所有向外的edge里找一个weight最小的edge扩展出去…重复这个过程.</p>
<ul>
<li>为什么这种方法符合第三步(invariant that A is still a tree)呢?</li>
</ul>
<p>因为Prim的操作本质就像DFS/BFS一个图来创造tree一样, 保持一个visited(也就是我们刚才说的V)来记录已经访问过的vertex. </p>
<p>而创造cycle需要有back edge, 也就是新加入的edge指向了已经visited的部分.</p>
<p>Prim的做法要求每次都拓展一个新的vertex, 所以不可能出现新加入的edge创造cycle的情况.</p>
<ul>
<li>一些定义:<br>假如一个graph G = (V, E)</li>
</ul>
<ol start="0">
<li><strong>Cut</strong>: a cut is a subset of vertex V. V里随意选的vertex集合.</li>
<li><strong>Cut set</strong>: the subset of edges with exactly one endpoint in S. 把这些随意选出来的vertex视作一个整体之后, “向外的”edge之和.</li>
<li><strong>Cycle</strong>: Set of edges of the form a-b, b-c, c-d, …, y-z, z-a. (需要至少有一个back edge, 从z指向a)</li>
</ol>
<p>(quiz会考的概念)</p>
<ol start="3">
<li><strong>Cut property</strong>: 任意一个cutset里, weight最小的一个edge, 一定在MST里. (一句话概括Prim的方法)</li>
<li><strong>Cycle property</strong>: 任意一个cycle里, weight最大的一个edge, 一定不在MST里. </li>
</ol>
<h3 id="Kruskal的方法"><a href="#Kruskal的方法" class="headerlink" title="Kruskal的方法"></a>Kruskal的方法</h3><p>Kruskal的方法是对刚才介绍的general的Greedy方法更直白的表达.</p>
<p>先sort所有的edge, 从小到大.</p>
<p>开一个空集把最小的edge加进去. <code>A = {e_0}</code>.</p>
<p>以从小到大的方法把edge加入<code>A</code>, 每一次检查是否会创造cycle, 不会创造的话就不加入.</p>
<h3 id="线下Tutorial"><a href="#线下Tutorial" class="headerlink" title="线下Tutorial"></a>线下Tutorial</h3><p>walk though prim和Kruskal的方法. (final一定会考)</p>
<h3 id="Prim的python实现"><a href="#Prim的python实现" class="headerlink" title="Prim的python实现"></a>Prim的python实现</h3><p>参考代码 (0修改, 如在作业中参考, 请务必reference!):</p>
<p><a href="https://www.geeksforgeeks.org/prims-mst-for-adjacency-list-representation-greedy-algo-6/" target="_blank" rel="noopener">Geeks for Geeks</a><br><a href="https://codereview.stackexchange.com/questions/174946/prims-algorithm-using-heapq-module-in-python" target="_blank" rel="noopener">Stack Exchange</a></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> heapq <span class="keyword">import</span> heappush, heappop</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Graph</span><span class="params">()</span>:</span> </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, n)</span>:</span> </span><br><span class="line">        self.graph = defaultdict(list) </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addEdge</span><span class="params">(self, src, dest, weight)</span>:</span> </span><br><span class="line">        newNode = [dest, weight] </span><br><span class="line">        self.graph[src].insert(<span class="number">0</span>, newNode) </span><br><span class="line">        newNode = [src, weight] </span><br><span class="line">        self.graph[dest].insert(<span class="number">0</span>, newNode) </span><br><span class="line"></span><br><span class="line">graph = Graph(<span class="number">9</span>) </span><br><span class="line">graph.addEdge(<span class="number">0</span>, <span class="number">1</span>, <span class="number">4</span>) </span><br><span class="line">graph.addEdge(<span class="number">0</span>, <span class="number">7</span>, <span class="number">8</span>) </span><br><span class="line">graph.addEdge(<span class="number">1</span>, <span class="number">2</span>, <span class="number">8</span>) </span><br><span class="line">graph.addEdge(<span class="number">1</span>, <span class="number">7</span>, <span class="number">11</span>) </span><br><span class="line">graph.addEdge(<span class="number">2</span>, <span class="number">3</span>, <span class="number">7</span>) </span><br><span class="line">graph.addEdge(<span class="number">2</span>, <span class="number">8</span>, <span class="number">2</span>) </span><br><span class="line">graph.addEdge(<span class="number">2</span>, <span class="number">5</span>, <span class="number">4</span>) </span><br><span class="line">graph.addEdge(<span class="number">3</span>, <span class="number">4</span>, <span class="number">9</span>) </span><br><span class="line">graph.addEdge(<span class="number">3</span>, <span class="number">5</span>, <span class="number">14</span>) </span><br><span class="line">graph.addEdge(<span class="number">4</span>, <span class="number">5</span>, <span class="number">10</span>) </span><br><span class="line">graph.addEdge(<span class="number">5</span>, <span class="number">6</span>, <span class="number">2</span>) </span><br><span class="line">graph.addEdge(<span class="number">6</span>, <span class="number">7</span>, <span class="number">1</span>) </span><br><span class="line">graph.addEdge(<span class="number">6</span>, <span class="number">8</span>, <span class="number">6</span>) </span><br><span class="line">graph.addEdge(<span class="number">7</span>, <span class="number">8</span>, <span class="number">7</span>) </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">minimum_spanning_tree_cost</span><span class="params">(graph)</span>:</span></span><br><span class="line">    <span class="string">"""Return the sum of the costs of the edges in the minimum spanning</span></span><br><span class="line"><span class="string">    tree for the given graph, which must be a mapping from nodes to an</span></span><br><span class="line"><span class="string">    iterable of (neighbour, edge-cost) pairs.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    total = <span class="number">0</span>                   <span class="comment"># Total cost of edges in tree</span></span><br><span class="line">    explored = set()            <span class="comment"># Set of vertices in tree</span></span><br><span class="line">    start = list(graph.keys())[<span class="number">0</span>]   <span class="comment"># Arbitrary starting vertex</span></span><br><span class="line">    unexplored = [(<span class="number">0</span>, start)]   <span class="comment"># Unexplored edges ordered by cost</span></span><br><span class="line">    <span class="keyword">while</span> unexplored:</span><br><span class="line">        cost, winner = heappop(unexplored)</span><br><span class="line">        <span class="keyword">if</span> winner <span class="keyword">not</span> <span class="keyword">in</span> explored:</span><br><span class="line">            explored.add(winner)</span><br><span class="line">            total += cost</span><br><span class="line">            <span class="keyword">for</span> neighbour, cost <span class="keyword">in</span> graph[winner]:</span><br><span class="line">                <span class="keyword">if</span> neighbour <span class="keyword">not</span> <span class="keyword">in</span> explored:</span><br><span class="line">                    heappush(unexplored, (cost, neighbour))</span><br><span class="line">    <span class="keyword">return</span> total</span><br><span class="line"></span><br><span class="line">print(minimum_spanning_tree_cost(graph.graph)) <span class="comment"># 37</span></span><br></pre></td></tr></table></figure>
<p>Kruskal的python实现涉及Union Find方法, 以后会在Union Find博客中放出.</p>
<h2 id="单源最短路径之Dijkstra"><a href="#单源最短路径之Dijkstra" class="headerlink" title="单源最短路径之Dijkstra"></a>单源最短路径之Dijkstra</h2><p>对单源最短路径, 我们需要知道起点, 终点不重要. </p>
<h3 id="一句话记住怎么做-未优化"><a href="#一句话记住怎么做-未优化" class="headerlink" title="一句话记住怎么做: (未优化)"></a>一句话记住怎么做: (未优化)</h3><ol>
<li>把所有除了起点以外的vertex标记成infinite distance</li>
<li>从起点开始, 每一次探索当前最小distance的vertex向外的边, 并将累积的和记下来.</li>
<li>如果遇到已探索过的部分, 需要比较新的路径是否比已知路径更小并进行更新</li>
</ol>
<h3 id="python实现-未优化"><a href="#python实现-未优化" class="headerlink" title="python实现(未优化)"></a>python实现(未优化)</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dijkstra</span><span class="params">(start, graph)</span>:</span></span><br><span class="line">        shortest_distance = &#123;&#125;</span><br><span class="line">        predecessor = &#123;&#125; <span class="comment">#用来记录path, 达到终点后可以一路trace回来.</span></span><br><span class="line">        unSeenNodes = graph</span><br><span class="line">        infinity= float(<span class="string">'inf'</span>) <span class="comment">#先设置成无限大</span></span><br><span class="line">        path = []</span><br><span class="line">        <span class="keyword">for</span> node <span class="keyword">in</span> unSeenNodes:</span><br><span class="line">            shortest_distance[node] = infinity</span><br><span class="line">        shortest_distance[start]= <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> unSeenNodes: <span class="comment">#以traverse完所有vertex为终点.</span></span><br><span class="line">            minNode = <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">#先找当前distance值最小的vertex来探索</span></span><br><span class="line">            <span class="keyword">for</span> node <span class="keyword">in</span> unSeenNodes: <span class="comment">#这一步可以优化的.</span></span><br><span class="line">                <span class="keyword">if</span> minNode==<span class="keyword">None</span>:</span><br><span class="line">                    minNode = node</span><br><span class="line">                <span class="keyword">elif</span> shortest_distance[node]&lt;shortest_distance[minNode]:</span><br><span class="line">                    minNode = node</span><br><span class="line"></span><br><span class="line">            <span class="comment">#找到了这个vertex, 探索其邻居</span></span><br><span class="line">            <span class="keyword">for</span> neighbour <span class="keyword">in</span> graph[minNode].keys():</span><br><span class="line">                weight = graph[minNode][neighbour]</span><br><span class="line">                <span class="keyword">if</span> shortest_distance[neighbour] &gt; weight + shortest_distance[minNode]: </span><br><span class="line">                    <span class="comment">#如果邻居是已经探索过的, 比较其已知distance和更新的distance, 取更小值.</span></span><br><span class="line">                    predecessor[neighbour] = minNode</span><br><span class="line">                    shortest_distance[neighbour] = weight + shortest_distance[minNode]</span><br><span class="line">            unSeenNodes.pop(minNode)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> shortest_distance</span><br></pre></td></tr></table></figure>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/USYD3027/" rel="tag"># USYD3027</a>
          
            <a href="/tags/Greedy/" rel="tag"># Greedy</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/03/07/2123-week2/" rel="next" title="USYD2123 Linked List tutorial">
                <i class="fa fa-chevron-left"></i> USYD2123 Linked List tutorial
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Shirley Hou</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">7</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">3</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">6</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Week3-贪心"><span class="nav-number">1.</span> <span class="nav-text">Week3 贪心</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#证明Greedy的三种方法"><span class="nav-number">1.1.</span> <span class="nav-text">证明Greedy的三种方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Interval-Scheduling-Proble-Activity-Selection-Problem"><span class="nav-number">1.2.</span> <span class="nav-text">Interval Scheduling Proble/(Activity Selection Problem)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#定义"><span class="nav-number">1.2.1.</span> <span class="nav-text">定义:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#一句话记住怎么做"><span class="nav-number">1.2.2.</span> <span class="nav-text">一句话记住怎么做:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#如果要证明"><span class="nav-number">1.2.3.</span> <span class="nav-text">如果要证明..:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#证明"><span class="nav-number">1.2.4.</span> <span class="nav-text">证明:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#伪代码"><span class="nav-number">1.3.</span> <span class="nav-text">伪代码</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#python-实现"><span class="nav-number">1.4.</span> <span class="nav-text">python 实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Minimize-Lateness"><span class="nav-number">1.5.</span> <span class="nav-text">Minimize Lateness</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#一句话记住怎么做-1"><span class="nav-number">1.5.1.</span> <span class="nav-text">一句话记住怎么做:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Minimum-Spanning-Tree-MST"><span class="nav-number">1.6.</span> <span class="nav-text">Minimum Spanning Tree (MST)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#概念"><span class="nav-number">1.6.1.</span> <span class="nav-text">概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#一句话记住怎么做-2"><span class="nav-number">1.6.2.</span> <span class="nav-text">一句话记住怎么做:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Prim的方法"><span class="nav-number">1.6.3.</span> <span class="nav-text">Prim的方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Kruskal的方法"><span class="nav-number">1.6.4.</span> <span class="nav-text">Kruskal的方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#线下Tutorial"><span class="nav-number">1.6.5.</span> <span class="nav-text">线下Tutorial</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Prim的python实现"><span class="nav-number">1.6.6.</span> <span class="nav-text">Prim的python实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#单源最短路径之Dijkstra"><span class="nav-number">1.7.</span> <span class="nav-text">单源最短路径之Dijkstra</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#一句话记住怎么做-未优化"><span class="nav-number">1.7.1.</span> <span class="nav-text">一句话记住怎么做: (未优化)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#python实现-未优化"><span class="nav-number">1.7.2.</span> <span class="nav-text">python实现(未优化)</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Shirley Hou</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
