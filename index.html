<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta property="og:type" content="website">
<meta property="og:title" content="Shirley&#39;s blog">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Shirley&#39;s blog">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Shirley&#39;s blog">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/">





  <title>Shirley's blog</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Shirley's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">代码小白的学习笔记</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/16/3027-week3/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Shirley Hou">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Shirley's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/16/3027-week3/" itemprop="url">Greedy Intro</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-03-16T10:31:56+11:00">
                2019-03-16
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/USYD/" itemprop="url" rel="index">
                    <span itemprop="name">USYD</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/USYD/CLRS/" itemprop="url" rel="index">
                    <span itemprop="name">CLRS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>CLRS: 算法导论</p>
<h1 id="Week3-贪心"><a href="#Week3-贪心" class="headerlink" title="Week3 贪心"></a>Week3 贪心</h1><p><br>定义: A greedy algorithm <strong>always makes the choice that looks best at the moment.</strong> That is, it makes a locally optimal choice in the hope that this choice will lead to a globally optimal solution.</p>
<p>举一个pramp上遇到的经典例子. 如果有一颗普通的二叉树, 每一条路径都有一个正的cost, 求从root到leaf最小的cost是多少.<br>比如:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">             R                  ----Root</span><br><span class="line">        (2)     (1)     </span><br><span class="line">      r.l        R.r            ----Children</span><br><span class="line">   (3)   (1)    (0)   null    </span><br><span class="line">R.l.l   R.l.r   R.r.l           ----GrandChildren</span><br></pre></td></tr></table></figure></p>
<p>对于这道题, 我们从leaf开始返回自己的cost, 在每一个parent层(有点像商科里概率树里的decision vertex)做决策: 目前累积下来的left child tree和right child tree哪个更小就选哪个加上自己继续往上传递. 这样每一层选下来的结果(locally)在root这一层(globally也一定是最小的. </p>
<p>学校lecture里cover 4个经典问题.</p>
<ul>
<li>Interval Scheduling Problem</li>
<li>Minimizing Lateness</li>
<li>Minimum Spanning Tree</li>
<li>Shortest Path (Dijkstra)</li>
</ul>
<h2 id="证明Greedy的三种方法"><a href="#证明Greedy的三种方法" class="headerlink" title="证明Greedy的三种方法"></a>证明Greedy的三种方法</h2><ul>
<li>Exchange Argument (最好, 推荐在asm1里用)</li>
</ul>
<p>Transform any solution to the one found by the greedy algorithm without hurting its quality.</p>
<ul>
<li>Greedy algorithm stays ahead:</li>
</ul>
<p>Show after each step of the greedy algorithm its solution is at least as good as other algorithms.</p>
<ul>
<li>Structural (推荐在asm1里用)</li>
</ul>
<p>Discover a bound asserting that every possible solution must have a certain value and your algorithm always achieves this bound.</p>
<h2 id="Interval-Scheduling-Proble-Activity-Selection-Problem"><a href="#Interval-Scheduling-Proble-Activity-Selection-Problem" class="headerlink" title="Interval Scheduling Proble/(Activity Selection Problem)"></a>Interval Scheduling Proble/(Activity Selection Problem)</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义:"></a>定义:</h3><p>有一组活动 S = {a1, a2, .. an}. 每一个活动有[s, f)两个时间代表开始和结束.<br>如果有两个活动, a_i和a_j, 它们compatible的话, 就说明它们开始和结束的时间没有任何的重叠 [s_i, f_i) does not overlap with [s_j, f_j). 如果两个活动重叠的话我们就不能都选. 我们希望给定一段时间, 能够从这一堆S中选择数量最多的活动.</p>
<h3 id="一句话记住怎么做"><a href="#一句话记住怎么做" class="headerlink" title="一句话记住怎么做:"></a>一句话记住怎么做:</h3><p>Keep choosing the activity that finishes first, keep only the activities compatible with this activity, and repeat until no activities remain.</p>
<h3 id="如果要证明"><a href="#如果要证明" class="headerlink" title="如果要证明..:"></a>如果要证明..:</h3><ul>
<li>定义</li>
</ul>
<p>对任何subproblem S_k, let a_m be the earliest finish time one in S_k, then a_m is included in the optimal solution for S_k.</p>
<ul>
<li>什么是subproblem? </li>
</ul>
<p>subproblem就是做数学归纳法里必须的一步, 如果大家还记得, 我们一般先证明1, 再证明k, 推到k+1. 可以理解为这个第k步.</p>
<p>在greedy里, 如果subproblem(第k步)有一个最优解, 那这个最优解也一定包含在k+1步里.</p>
<h3 id="证明"><a href="#证明" class="headerlink" title="证明:"></a>证明:</h3><p>假设S这个subproblem S_k 有两个解A_k, A_k’. 然后我们的活动集S里里有两个活动, a_j和a_m. 但是a_m是结束时间最早的那个, 有 f_m &lt;= f_j.<br>我们设 A_k 里有a_j但是没有a_m, 也就是不包括结束时间最早的那个.</p>
<p>另外, 我们使得(我们要证明的真正的最优解)A_k’ = A_k - a_j + a_m 作为一个含有a_m但不含有a_j的解. </p>
<p>—梳理一下, A_k和A_k’目前唯一的区别就是, A_k里有a_j没有a_m,  A_k没有<br>我们要证明A_k’不比A_k差, 甚至要更好. 以此证明我们一定要包含a_m.</p>
<p>首先, A_k’ = A_k- a_j + a_m 一增一减, A_k’的大小还是和A_k的大小一样. <br>因为为了符合题意, 最优解里的活动已经不会overlap each other, 再加上f_m &lt; f_j, 所以所以这样换下来, 还是不会有overlap的情况, 并不会对a_m后面的事件产生影响.</p>
<p>既然用a_m换掉a_j并不会影响结果的大小, 说明我们可以确定a_m一定会在最优解里了.</p>
<h2 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">sort S by finish time. </span><br><span class="line"></span><br><span class="line">n = S.length</span><br><span class="line">A = &#123;S[0]&#125;</span><br><span class="line">k = 1</span><br><span class="line">for m = 2 to n:</span><br><span class="line">    if S[m].start&gt;=S[k].finish:</span><br><span class="line">        A.add(S[m])</span><br><span class="line">        k = m</span><br><span class="line">return A</span><br></pre></td></tr></table></figure>
<h2 id="python-代码"><a href="#python-代码" class="headerlink" title="python 代码"></a>python 代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Activity</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, start, finish)</span>:</span></span><br><span class="line">        self.start = start</span><br><span class="line">        self.finish = finish</span><br><span class="line">    </span><br><span class="line">S = [</span><br><span class="line">    Activity(<span class="number">0</span>,<span class="number">6</span>),</span><br><span class="line">    Activity(<span class="number">1</span>,<span class="number">4</span>),</span><br><span class="line">    Activity(<span class="number">3</span>,<span class="number">5</span>),</span><br><span class="line">    Activity(<span class="number">3</span>,<span class="number">8</span>),</span><br><span class="line">    Activity(<span class="number">4</span>,<span class="number">7</span>),</span><br><span class="line">    Activity(<span class="number">5</span>,<span class="number">9</span>),</span><br><span class="line">    Activity(<span class="number">6</span>,<span class="number">10</span>),</span><br><span class="line">    Activity(<span class="number">8</span>,<span class="number">11</span>),</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">intervalScheduling</span><span class="params">(S, start_time, finish_time)</span>:</span></span><br><span class="line"></span><br><span class="line">    S.sort(key= <span class="keyword">lambda</span> x : x.finish)</span><br><span class="line">    k = <span class="number">0</span></span><br><span class="line">    n = len(S)</span><br><span class="line">    <span class="keyword">while</span>(k&lt;len(S)):</span><br><span class="line">        s = S[k]</span><br><span class="line">        <span class="keyword">if</span> s.start&gt;start_time:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        k+=<span class="number">1</span></span><br><span class="line"></span><br><span class="line">    A=[S[k]]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> m <span class="keyword">in</span> range(k+<span class="number">1</span>, n):</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> S[m].start&gt;=S[k].finish <span class="keyword">and</span> S[m].finish&lt;=finish_time:</span><br><span class="line">            A.append(S[m])</span><br><span class="line">            k = m</span><br><span class="line">    <span class="keyword">return</span> A</span><br><span class="line"></span><br><span class="line">solution = intervalScheduling(S, <span class="number">0</span>, <span class="number">11</span>)</span><br><span class="line">print(len(solution))</span><br><span class="line"><span class="keyword">for</span> s <span class="keyword">in</span> solution:</span><br><span class="line">    print(s.start, s.finish)</span><br></pre></td></tr></table></figure>
<h2 id="Minimize-Lateness"><a href="#Minimize-Lateness" class="headerlink" title="Minimize Lateness"></a>Minimize Lateness</h2><p>这个问题usyd的证明省略了非常多的前后知识, 如果要严格的证明需要很长的篇幅. 可以直接参考lecture slides里的内容.<br>与slides相同但阅读起来更完善的的资料:<a href="https://ocw.tudelft.nl/wp-content/uploads/Algoritmiek_Scheduling_to_Minimize_Maximum_Lateness.pdf" target="_blank" rel="noopener">TU Delft对于这个问题的讲义</a></p>
<h3 id="一句话记住怎么做-1"><a href="#一句话记住怎么做-1" class="headerlink" title="一句话记住怎么做:"></a>一句话记住怎么做:</h3><p>直接按每一个task的deadline排列, 不要有idle time.</p>
<ol>
<li>首先, 显然因为每项任务没有开始时间的要求, optimal solution一定是没有idle time的. idle time的意思是闲着什么都不做的时间.</li>
<li>inversion的意思是有两个task i和k, d_i &lt; d_k, 但是k却被放在了i的前面.</li>
<li>Greedy的方法是让deadline前的task先完成, 所以没有inversion.</li>
</ol>
<p>问题: What is the difference in maximum lateness between two schedules<br>without inversions and without idle time?</p>
<ul>
<li>没有区别. </li>
</ul>
<p>假如所有的task的deadline都是确定的, 而且没有inversion, 那排列的方法就是唯一的, 最后的lateness也是唯一的.<br>只有当, 如果有两个task i和 j它们的deadline相等的时候, 无论i放前面还是j放前面, lateness都一样.</p>
<ol start="4">
<li>如果一个schedule里没有idle时间而且只有一对inversion, 那么这对inversion的task是连续的.</li>
</ol>
<p>问题: 如果交换这样一对task(原本是i, j, d_i &lt; d_j 但i放在了j后面), 会对lateness造成什么影响?</p>
<ul>
<li>subproblem一样, 总的finish时间是一样的. finish时间要么是f_i要么是f_j.</li>
<li>结论:如果交换回来让 i在j前面, 会严格的减少或者保持现有的lateness.</li>
</ul>
<p>如何用Exchange Argument?<br>(slides里的证明)</p>
<h2 id="Minimum-Spanning-Tree-MST"><a href="#Minimum-Spanning-Tree-MST" class="headerlink" title="Minimum Spanning Tree (MST)"></a>Minimum Spanning Tree (MST)</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>Tree, spanning tree 和minimum spanning tree的定义层层递进</p>
<ul>
<li><p>Tree: 没有cycle的graph</p>
</li>
<li><p>Spanning Tree: 没有cycle而且连接graph里所有vertices的tree.</p>
</li>
<li><p>Minimum Spanning Tree: 所有可能的spanning tree里edge weight之和最小的spanning tree.</p>
</li>
</ul>
<h3 id="一句话记住怎么做-2"><a href="#一句话记住怎么做-2" class="headerlink" title="一句话记住怎么做:"></a>一句话记住怎么做:</h3><ul>
<li>如何找MST? 一个general的方法</li>
</ul>
<p>把所有edge按照weight从小到大来排列.<br>我们知道, 一个tree里最多只能有V-1个edge,否则就会有cycle, 不再是tree.</p>
<p>开一个空集A来存MST里所需要的edge.</p>
<p>从小到大来往A里加edge, 条件是加进来edge以后需要依旧要保持tree的特性, 不能产生cycle.</p>
<p>(这一段的证明需参考CLRS)</p>
<ul>
<li>如何证明我们这样做是对的?</li>
</ul>
<p>(Greedy stays ahead方法)</p>
<ol>
<li>Invariant: Prior to each iteration, A is a subset of some minimum spanning tree</li>
<li>Start from empty set. Empty set is certainly a subset of solution.</li>
<li>During each iteration, we make sure the edge (u,v) added does not hurting the invariant that A is still a tree. (之后我会解释为什么prim和kruskal的方法可以make sure这一点)</li>
<li>And since we sorted the edge by weight, the edge (u,v) adds smallest weight to the set A, so A’s total weight is minimized.</li>
<li>Therefore invariant still holds after we add edge (u,v)</li>
</ol>
<h3 id="Prim的方法"><a href="#Prim的方法" class="headerlink" title="Prim的方法"></a>Prim的方法</h3><p>选定一个随意的vertex, 记为set V = {n_0}</p>
<p>从这个vertex有的edge里找一个weight最小的edge扩展出去, 把这个edge另一端的vertex加进V里来.</p>
<p>当前 V = {n_0, n_1}.从这两个vertex所有向外的edge里找一个weight最小的edge扩展出去…重复这个过程.</p>
<ul>
<li>为什么这种方法符合第三步(invariant that A is still a tree)呢?</li>
</ul>
<p>因为Prim的操作本质就像DFS/BFS一个图来创造树一样, 保持一个visited(也就是我们刚才说的V)来记录已经访问过的vertex.<br>而创造cycle需要有back edge, 也就是新加入的edge指向了已经visited的部分.<br>Prim的做法要求每次都拓展一个新的vertex, 所以不可能出现新加入的edge创造cycle的情况.</p>
<ul>
<li>一些定义:<br>假如一个graph G = (V, E)</li>
</ul>
<ol start="0">
<li>Cut: a cut is a subset of vertex V. V里随意选的vertex集合.</li>
<li>Cut set: the subset of edges with exactly one endpoint in S. 把这些随意选出来的vertex视作一个整体之后, “向外的”edge之和.</li>
<li>Cycle: Set of edges of the form a-b, b-c, c-d, …, y-z, z-a. (需要至少有一个back edge, 从z指向a)</li>
</ol>
<p>(quiz会考的概念)</p>
<ol start="3">
<li>Cut property: 任意一个cutset里, weight最小的一个edge, 一定在MST里. (一句话概括Prim的方法)</li>
<li>Cycle property: 任意一个cycle里, weight最大的一个edge, 一定不在MST里. </li>
</ol>
<h3 id="Kruskal的方法"><a href="#Kruskal的方法" class="headerlink" title="Kruskal的方法"></a>Kruskal的方法</h3><p>Kruskal的方法是对刚才介绍的general的Greedy方法更直白的表达.</p>
<p>先sort所有的edge, 从小到大.</p>
<p>开一个空集把最小的edge加进去. A = {e_0}.</p>
<p>以从小到大的方法把edge加入A, 每一次检查是否会创造cycle, 不会创造的话就不加入.</p>
<h3 id="线下Tutorial"><a href="#线下Tutorial" class="headerlink" title="线下Tutorial"></a>线下Tutorial</h3><p>walk though prim和Kruskal的方法. (final一定会考)</p>
<h3 id="Prim的python实现"><a href="#Prim的python实现" class="headerlink" title="Prim的python实现"></a>Prim的python实现</h3><p>参考代码 (0修改, 如在作业中参考, 请务必reference!):</p>
<p><a href="https://www.geeksforgeeks.org/prims-mst-for-adjacency-list-representation-greedy-algo-6/" target="_blank" rel="noopener">Geeks for Geeks</a><br><a href="https://codereview.stackexchange.com/questions/174946/prims-algorithm-using-heapq-module-in-python" target="_blank" rel="noopener">Stack Exchange</a></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> heapq <span class="keyword">import</span> heappush, heappop</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Graph</span><span class="params">()</span>:</span> </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, n)</span>:</span> </span><br><span class="line">        self.graph = defaultdict(list) </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addEdge</span><span class="params">(self, src, dest, weight)</span>:</span> </span><br><span class="line">        newNode = [dest, weight] </span><br><span class="line">        self.graph[src].insert(<span class="number">0</span>, newNode) </span><br><span class="line">        newNode = [src, weight] </span><br><span class="line">        self.graph[dest].insert(<span class="number">0</span>, newNode) </span><br><span class="line"></span><br><span class="line">graph = Graph(<span class="number">9</span>) </span><br><span class="line">graph.addEdge(<span class="number">0</span>, <span class="number">1</span>, <span class="number">4</span>) </span><br><span class="line">graph.addEdge(<span class="number">0</span>, <span class="number">7</span>, <span class="number">8</span>) </span><br><span class="line">graph.addEdge(<span class="number">1</span>, <span class="number">2</span>, <span class="number">8</span>) </span><br><span class="line">graph.addEdge(<span class="number">1</span>, <span class="number">7</span>, <span class="number">11</span>) </span><br><span class="line">graph.addEdge(<span class="number">2</span>, <span class="number">3</span>, <span class="number">7</span>) </span><br><span class="line">graph.addEdge(<span class="number">2</span>, <span class="number">8</span>, <span class="number">2</span>) </span><br><span class="line">graph.addEdge(<span class="number">2</span>, <span class="number">5</span>, <span class="number">4</span>) </span><br><span class="line">graph.addEdge(<span class="number">3</span>, <span class="number">4</span>, <span class="number">9</span>) </span><br><span class="line">graph.addEdge(<span class="number">3</span>, <span class="number">5</span>, <span class="number">14</span>) </span><br><span class="line">graph.addEdge(<span class="number">4</span>, <span class="number">5</span>, <span class="number">10</span>) </span><br><span class="line">graph.addEdge(<span class="number">5</span>, <span class="number">6</span>, <span class="number">2</span>) </span><br><span class="line">graph.addEdge(<span class="number">6</span>, <span class="number">7</span>, <span class="number">1</span>) </span><br><span class="line">graph.addEdge(<span class="number">6</span>, <span class="number">8</span>, <span class="number">6</span>) </span><br><span class="line">graph.addEdge(<span class="number">7</span>, <span class="number">8</span>, <span class="number">7</span>) </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">minimum_spanning_tree_cost</span><span class="params">(graph)</span>:</span></span><br><span class="line">    <span class="string">"""Return the sum of the costs of the edges in the minimum spanning</span></span><br><span class="line"><span class="string">    tree for the given graph, which must be a mapping from nodes to an</span></span><br><span class="line"><span class="string">    iterable of (neighbour, edge-cost) pairs.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    total = <span class="number">0</span>                   <span class="comment"># Total cost of edges in tree</span></span><br><span class="line">    explored = set()            <span class="comment"># Set of vertices in tree</span></span><br><span class="line">    start = list(graph.keys())[<span class="number">0</span>]   <span class="comment"># Arbitrary starting vertex</span></span><br><span class="line">    unexplored = [(<span class="number">0</span>, start)]   <span class="comment"># Unexplored edges ordered by cost</span></span><br><span class="line">    <span class="keyword">while</span> unexplored:</span><br><span class="line">        cost, winner = heappop(unexplored)</span><br><span class="line">        <span class="keyword">if</span> winner <span class="keyword">not</span> <span class="keyword">in</span> explored:</span><br><span class="line">            explored.add(winner)</span><br><span class="line">            total += cost</span><br><span class="line">            <span class="keyword">for</span> neighbour, cost <span class="keyword">in</span> graph[winner]:</span><br><span class="line">                <span class="keyword">if</span> neighbour <span class="keyword">not</span> <span class="keyword">in</span> explored:</span><br><span class="line">                    heappush(unexplored, (cost, neighbour))</span><br><span class="line">    <span class="keyword">return</span> total</span><br><span class="line"></span><br><span class="line">print(minimum_spanning_tree_cost(graph.graph)) <span class="comment"># 37</span></span><br></pre></td></tr></table></figure>
<p>Kruskal的python实现涉及Union Find方法, 以后会在Union Find博客中放出.</p>
<h2 id="单源最短路径之Dijkstra"><a href="#单源最短路径之Dijkstra" class="headerlink" title="单源最短路径之Dijkstra"></a>单源最短路径之Dijkstra</h2><p>对单源最短路径, 我们需要知道起点, 终点不重要. </p>
<h3 id="一句话记住怎么做-未优化"><a href="#一句话记住怎么做-未优化" class="headerlink" title="一句话记住怎么做: (未优化)"></a>一句话记住怎么做: (未优化)</h3><ol>
<li>把所有除了起点以外的vertex标记成infinite distance</li>
<li>从起点开始, 每一次探索当前最小distance的vertex向外的边, 并将累积的和记下来.</li>
<li>如果遇到已探索过的部分, 需要比较新的路径是否比已知路径更小并进行更新</li>
</ol>
<h3 id="python实现-未优化"><a href="#python实现-未优化" class="headerlink" title="python实现(未优化)"></a>python实现(未优化)</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dijkstra</span><span class="params">(start, graph)</span>:</span></span><br><span class="line">        shortest_distance = &#123;&#125;</span><br><span class="line">        predecessor = &#123;&#125; <span class="comment">#用来记录path, 达到终点后可以一路trace回来.</span></span><br><span class="line">        unSeenNodes = graph</span><br><span class="line">        infinity= float(<span class="string">'inf'</span>) <span class="comment">#先设置成无限大</span></span><br><span class="line">        path = []</span><br><span class="line">        <span class="keyword">for</span> node <span class="keyword">in</span> unSeenNodes:</span><br><span class="line">            shortest_distance[node] = infinity</span><br><span class="line">        shortest_distance[start]= <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> unSeenNodes: <span class="comment">#以traverse完所有vertex为终点.</span></span><br><span class="line">            minNode = <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">#先找当前distance值最小的vertex来探索</span></span><br><span class="line">            <span class="keyword">for</span> node <span class="keyword">in</span> unSeenNodes: <span class="comment">#这一步可以优化的.</span></span><br><span class="line">                <span class="keyword">if</span> minNode==<span class="keyword">None</span>:</span><br><span class="line">                    minNode = node</span><br><span class="line">                <span class="keyword">elif</span> shortest_distance[node]&lt;shortest_distance[minNode]:</span><br><span class="line">                    minNode = node</span><br><span class="line"></span><br><span class="line">            <span class="comment">#找到了这个vertex, 探索其邻居</span></span><br><span class="line">            <span class="keyword">for</span> neighbour <span class="keyword">in</span> graph[minNode].keys():</span><br><span class="line">                weight = graph[minNode][neighbour]</span><br><span class="line">                <span class="keyword">if</span> shortest_distance[neighbour] &gt; weight + shortest_distance[minNode]: </span><br><span class="line">                    <span class="comment">#如果邻居是已经探索过的, 比较其已知distance和更新的distance, 取更小值.</span></span><br><span class="line">                    predecessor[neighbour] = minNode</span><br><span class="line">                    shortest_distance[neighbour] = weight + shortest_distance[minNode]</span><br><span class="line">            unSeenNodes.pop(minNode)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> shortest_distance</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/07/2123-week2/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Shirley Hou">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Shirley's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/07/2123-week2/" itemprop="url">USYD2123 Linked List tutorial</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-03-07T11:41:44+11:00">
                2019-03-07
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/USYD/" itemprop="url" rel="index">
                    <span itemprop="name">USYD</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Week2-List-and-Linked-List-Stack-and-Queue"><a href="#Week2-List-and-Linked-List-Stack-and-Queue" class="headerlink" title="Week2 List and Linked List, Stack and Queue"></a>Week2 List and Linked List, Stack and Queue</h2><p>这周的知识点</p>
<p>了解以下数据结构的实现, time and space constraint</p>
<ul>
<li>array implementation of a list</li>
<li>singly and doubly linked list</li>
<li>doubly linked list Stack and Queue</li>
<li><strong>adv</strong> singly linked list stack and queue</li>
</ul>
<h3 id="python里的run-time和function-call测试方法"><a href="#python里的run-time和function-call测试方法" class="headerlink" title="python里的run time和function call测试方法"></a>python里的run time和function call测试方法</h3><h2 id="Tutorial"><a href="#Tutorial" class="headerlink" title="Tutorial"></a>Tutorial</h2><h3 id="Q3-Given-a-singly-linked-list-traverse-the-elements-of-the-list-in-reverse-order"><a href="#Q3-Given-a-singly-linked-list-traverse-the-elements-of-the-list-in-reverse-order" class="headerlink" title="Q3 : Given a singly linked list, traverse the elements of the list in reverse order."></a>Q3 : Given a singly linked list, traverse the elements of the list in reverse order.</h3><ul>
<li>Design an algorithm that uses O(1) extra space. </li>
</ul>
<p>首先我们需要了解题意, 是否真的要把linked list反过来.<br>比如 1-&gt;2-&gt;3 经过处理后变成 3-&gt;2-&gt;1.<br>如果只能使用O(1)的空间, 那么我们除了已经给的list的空间没有更多的地方来存储信息, 那么免不了对原本linkedlist的改动, 也就是<br>改变node之间next的指向.</p>
<p>O(1)的方法 有iterative和recursive两种解法, 推荐了解iterasive的写法.</p>
<p>在这之前, 先写一个helper function <code>print_linkedlist(head)</code>来帮忙检验. 我们默认<code>print_linkedlist</code>是时间O(n)空间O(1)的.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_linkedlist</span><span class="params">(head)</span>:</span></span><br><span class="line">    node = head</span><br><span class="line">    <span class="keyword">while</span>(node):</span><br><span class="line">        print(node.value) <span class="comment">#traversed</span></span><br><span class="line">        node = node.next</span><br></pre></td></tr></table></figure>
<p><strong>Iterasive method</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reverseList</span><span class="params">(head)</span>:</span></span><br><span class="line">    current = head</span><br><span class="line">    prev = <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(current):</span><br><span class="line">        </span><br><span class="line">        curr_next = current.next <span class="comment">#先存next, 下一步要走的点</span></span><br><span class="line">        current.next = prev <span class="comment"># **改变当前点的next位置. 反转的一步!**</span></span><br><span class="line">        prev = current <span class="comment">#更新prev称为当前点. </span></span><br><span class="line">        current = curr_next <span class="comment">#更新当前点为next, 下一步要走的点.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#理解视频: https://www.youtube.com/watch?v=sYcOK51hl-A</span></span><br><span class="line"></span><br><span class="line">    old_last_node = prev</span><br><span class="line">    <span class="keyword">return</span> old_last_node</span><br><span class="line"></span><br><span class="line">print_linkedlist(reverseList(head))</span><br></pre></td></tr></table></figure>
<p><strong>Recursive method</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reverseList</span><span class="params">(head)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    return the new head with the reversed linkedlist</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">if</span> head==<span class="keyword">None</span> <span class="keyword">or</span> head.next==<span class="keyword">None</span>:</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> head</span><br><span class="line">    old_second = self.reverseList(head.next)</span><br><span class="line">    head.next.next = head</span><br><span class="line">    head.next=<span class="keyword">None</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> old_second</span><br><span class="line"></span><br><span class="line">print_linkedlist(reverseList(head))</span><br></pre></td></tr></table></figure>
<ul>
<li>Design an algorithm that uses O(sqrt(n)) extra space. </li>
</ul>
<p>因为题目要求仅仅是reversely traverse, 有多余位置存储信息的话, 我们就可以事实上不改变node之间的联系了.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reverse_sqrt_n</span><span class="params">(head)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 为了方便描述 记 K = sqrt(n)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># # -------第一步: 找到list的长度------</span></span><br><span class="line">    <span class="comment"># 假设我们不知道这个list有多长, 我们首先需要获取长度信息.</span></span><br><span class="line">    n=<span class="number">0</span></span><br><span class="line">    node=head</span><br><span class="line">    <span class="keyword">while</span> node:</span><br><span class="line">        n+=<span class="number">1</span></span><br><span class="line">        node=node.next </span><br><span class="line">    <span class="comment">#to know how long is our linked list, time O(n), space O(1)</span></span><br><span class="line">    k=int(n**<span class="number">.5</span>)+<span class="number">1</span>  <span class="comment">#确定sqrt(n)的大小</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 到这一步为止 time用了n, space用了1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># ---------第二步: 存储每第K个node位置-------</span></span><br><span class="line">    <span class="comment"># 存储每第sqrt(k)个node</span></span><br><span class="line">    <span class="comment"># 一共有 k/sqrt(k)=sqrt(k)次操作, 存好了以后会使用sqrt(k)space.</span></span><br><span class="line"></span><br><span class="line">    i=<span class="number">0</span></span><br><span class="line">    node=self</span><br><span class="line">    lsa=[node]</span><br><span class="line">    node_stored_position_sequence=[] <span class="comment">#只是为了分析而用</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> node:</span><br><span class="line">        i+=<span class="number">1</span></span><br><span class="line">        count+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> i==k: </span><br><span class="line">            lsa.append(node)</span><br><span class="line">            node_stored_position_sequence.append(count) <span class="comment">#只是为了分析而用</span></span><br><span class="line">            i=<span class="number">0</span></span><br><span class="line">        last_node=node</span><br><span class="line">        node=node.next</span><br><span class="line">    <span class="keyword">if</span> i&gt;<span class="number">0</span>:</span><br><span class="line">        lsa.append(last_node)</span><br><span class="line">    <span class="comment"># print(node_stored_position_sequence)</span></span><br><span class="line">    <span class="comment"># 如果n=100的话,这里node_stored_position_sequence应该存了 [11, 22, 33, 44, 55, 66, 77, 88, 99]个node.</span></span><br><span class="line">    <span class="comment"># 到这一步为止 time用了2n, space用了K</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># -------第三步: 反向打印------</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 我们已经存了每第sqrt(n)个node的位置, 那么要如何反过来呢?</span></span><br><span class="line">    <span class="comment"># 每一次我们pop一个node, 并且记录上一次被pop的那个.</span></span><br><span class="line">    <span class="comment"># 处理最后一个node就是:顺序 node = node.next地把结果存起来,存到之前存的那个为止</span></span><br><span class="line">    <span class="comment"># 比如我们存22号node, 就一路 node = node.next 的把结果保存到一个list里, 直到遇到33号为止</span></span><br><span class="line">    <span class="comment"># 存完[22, 23, 24... 32]之后, 我们反着打印. 反着打印花的时间是K.</span></span><br><span class="line">    <span class="comment"># 这样我们操作K次, 每次使用K的空间.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 一共space cost是K, time cost则是n+n + K*K = 3n =  O(n).</span></span><br><span class="line"></span><br><span class="line">    start_node=lsa.pop()</span><br><span class="line">    print(start_node.value)</span><br><span class="line">    <span class="keyword">while</span> lsa: <span class="comment"># this happens K times. K = sqrt(K)</span></span><br><span class="line">        last_printed_node=start_node</span><br><span class="line">        start_node=lsa.pop()</span><br><span class="line">        node=start_node</span><br><span class="line">        ssa=[]</span><br><span class="line">        <span class="keyword">while</span> node!=last_printed_node:</span><br><span class="line">            ssa.append(node)</span><br><span class="line">            node=node.next</span><br><span class="line"></span><br><span class="line">        <span class="comment"># [print(v.value, end=" ") for v in ssa] </span></span><br><span class="line">        <span class="comment"># 如果打印的话, 这一步应该打印 sqrt(n) 次, 每一次打印一个 sqrt(n)长度的数组</span></span><br><span class="line">        ssa.reverse()</span><br><span class="line">        <span class="keyword">for</span> node <span class="keyword">in</span> ssa:</span><br><span class="line">            print(node.value)</span><br></pre></td></tr></table></figure></p>
<h3 id="Q5-Consider-the-problem-of-given-an-integer-n-generating-all-possible-permutations-of-1-2-3…n"><a href="#Q5-Consider-the-problem-of-given-an-integer-n-generating-all-possible-permutations-of-1-2-3…n" class="headerlink" title="Q5 : Consider the problem of given an integer n, generating all possible permutations of {1,2,3…n}"></a>Q5 : Consider the problem of given an integer n, generating all possible permutations of {1,2,3…n}</h3><ul>
<li>了解这道题里的复杂度分析是最重要的一点.</li>
</ul>
<p>举个例子<br>permute(3) = [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]]<br>显然 如果已经知道了permute(2), 那permute(3)则只需要在每一个permute(2)的任意一位置加入3这个数字 ,<br>[[1, 2], [2, 1]]<br>[[1,2,3], [1,3,2], [3,1,2]<br>[[2,1,3], [2,3,1], [3,2,1]].</p>
<p>所以, 时间复杂度由T(n) = n * T(n-1) + O(1) , 可以推出时间复杂度是 O(N!)<br>空间: O(N!) 因为要记录排列组合本身就需要O(N!)这么大的空间</p>
<ul>
<li>recursive method(推荐)</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">permute</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    :type n: int</span></span><br><span class="line"><span class="string">    :rtype: List[List[int]]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    return the list contains each lists of permutation</span></span><br><span class="line"><span class="string">    from &#123;1,2,..n&#125;</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    l = []</span><br><span class="line">    s = []</span><br><span class="line">    v = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(n+<span class="number">1</span>)] </span><br><span class="line">    <span class="comment"># 我们不用index 0的位置, 因为题目要求permute从1到n</span></span><br><span class="line">    <span class="comment"># 1 based index</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(l,s,v,index)</span>:</span></span><br><span class="line">        <span class="comment">#start is for the beginning position</span></span><br><span class="line">        <span class="keyword">if</span> index==n+<span class="number">1</span>:</span><br><span class="line">            l.append(s[:]) <span class="comment">#记录当前组合</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">else</span>: </span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,n+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> v[i]==<span class="number">0</span>:</span><br><span class="line">                    s.append(i)</span><br><span class="line">                    v[i]=<span class="number">1</span></span><br><span class="line">                    dfs(l,s,v,index+<span class="number">1</span>)</span><br><span class="line">                    v[i]=<span class="number">0</span></span><br><span class="line">                    s.pop() <span class="comment">#回溯操作</span></span><br><span class="line">    dfs(l,s,v,<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> l</span><br><span class="line">print(permute(<span class="number">3</span>))</span><br></pre></td></tr></table></figure>
<ul>
<li>iterative method(Heap’s algorithm)<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">permute_iterative_heap_s_algorithm</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    :type n: int</span></span><br><span class="line"><span class="string">    :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    c = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(n)]</span><br><span class="line">    A = [i+<span class="number">1</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(n)]</span><br><span class="line"></span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    res= [A[:]]</span><br><span class="line">    <span class="keyword">while</span> i &lt; n:</span><br><span class="line">        <span class="keyword">if</span>  c[i] &lt; i:</span><br><span class="line">            <span class="keyword">if</span> i%<span class="number">2</span>==<span class="number">0</span>:</span><br><span class="line">                A[<span class="number">0</span>],A[i] = A[i], A[<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                A[c[i]], A[i] = A[i],A[c[i]]</span><br><span class="line">            res.append(A[:])</span><br><span class="line">            c[i] += <span class="number">1</span></span><br><span class="line">            i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            c[i] = <span class="number">0</span></span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/05/3027-week2/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Shirley Hou">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Shirley's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/05/3027-week2/" itemprop="url">Graph Intro</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-03-05T16:24:14+11:00">
                2019-03-05
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/USYD/" itemprop="url" rel="index">
                    <span itemprop="name">USYD</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Week2-Graph"><a href="#Week2-Graph" class="headerlink" title="Week2 Graph"></a>Week2 Graph</h2><p>这周的定义比较多一些</p>
<h2 id="课程梳理"><a href="#课程梳理" class="headerlink" title="课程梳理"></a>课程梳理</h2><h3 id="名词梳理"><a href="#名词梳理" class="headerlink" title="名词梳理"></a>名词梳理</h3><ul>
<li><p><code>V</code>: <code>Node/Vertices</code> 点</p>
</li>
<li><p><code>E</code>: <code>Edges</code> 边</p>
</li>
<li><p>neighbour: 邻居, 一个vertex只需要走一条边就能到达的其他vertex.</p>
</li>
<li><p>degree of a vertex: 一个vertex的邻居个数, 简称<code>deg(V)</code></p>
</li>
<li><p>一般用<code>n</code>表示点的个数, <code>m</code>表示边的个数</p>
</li>
<li><p><code>Directed Graph</code>: 有向图. 意思是比如有一条边从 <code>A -&gt; B</code>, 并不意味着也同时有一条边从<code>B -&gt; A</code>. 这样的图里, 如果给了条件<code>A-&gt;B</code>, A的邻居可以有B, 但B的邻居并没有A. 所以, 有向图里如果<code>Edge(u,v)</code>并不等同于<code>E(v, u)</code>.</p>
</li>
<li><p><code>Undirected Graph</code>: 无向图. 意思是比如有一条边从 <code>A -&gt; B</code>, 那同时这条边也从 <code>B -&gt; A</code>, 就可以写成<code>A-B</code> .这样的图里, 如果给了条件<code>A-&gt;B</code>, 如果A的邻居有B, 那B邻居里就有A. </p>
</li>
</ul>
<p>以下的定义均描述<code>undirected graph</code></p>
<ul>
<li><p>Path: 路径, 比如 <code>[1-2, 2-3, 3-4]</code> 就可以构成由1到4的一条路径</p>
</li>
<li><p>Simple Path: 一条路径里所有的vertex都不出现第二次. 换言之, <code>simple path</code>没有<code>cycle</code>. 有cycle的path例如: <code>[1-2, 2-3, 3-1]</code>, 从1回到了1, 就构成了环.</p>
</li>
<li><p>Cycle: 正式定义是由 <code>[v1-v2, v2-v3, ... vk-1-vk]</code> 组成的一条path中, v1 == vk (k&gt;2), 而且前k-1个点都不相同.<br>简单的解释就是一条path开始和结束是重复的点, 从某点开始又回到了自己.</p>
</li>
<li><p>connected graph: 一个graph里任意两个的vertex都可以通过某条<code>path</code>连在一起. </p>
</li>
<li><p>tree: 树. 如果(undirected)图既是connected, 也没有cycle. </p>
</li>
<li><p>rooted tree: 有hierarchy层次结构的树, 你可以分清楚parent child这样的结构. 比如大家熟悉的二叉树binary tree就是这种.</p>
</li>
</ul>
<h3 id="重要定理"><a href="#重要定理" class="headerlink" title="重要定理"></a>重要定理</h3><ul>
<li>Number of edges in a <code>tree</code> with <strong>n</strong> nodes is <strong>n-1</strong>.<ul>
<li>用induction证明. </li>
</ul>
<ol>
<li>首先当 n = 1 的时候 edge是0. </li>
<li>设当 n = k 的时候 edge是 k-1, 这个时候的tree称为T. </li>
<li>因为T是connected而且没有cycle, 当去掉一个edge的时候一个tree就会被分成两个tree, 设为t1 和 t2.</li>
<li>设t1 有n1个vertex,  t2 有 n2个vertex. 显然 n1+n2 = k.</li>
<li>根据induction, n1有n1-1个edge, n2有n2-1个edge. 这两个分开的tree现在剩的总edge数是n1-1+n2-1 = (n1+n2)-2 = k-2.</li>
<li>因为刚才我们自己去掉了一个edge, 所以可以第3步出去掉之前T的edge一共有k-1个.</li>
</ol>
</li>
</ul>
<h3 id="图的实现"><a href="#图的实现" class="headerlink" title="图的实现"></a>图的实现</h3><p><strong>Adjacency matrix</strong></p>
<p>简称adj matrix.<br>它的表达方法很直观. 每一行是node, 列也是node, 两个node之间是否有edge记为成0或者1.<br>比如我们有三个node的一个graph:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">V = &#123;0,1,2,3&#125;</span><br><span class="line">E = &#123;0-1, 1-2, 1-3&#125;</span><br></pre></td></tr></table></figure>
<p>那么写成adj matrix一般可以这样</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">n = <span class="number">4</span></span><br><span class="line">adj_matrix = [[<span class="number">0</span> <span class="keyword">for</span> j <span class="keyword">in</span> range(n)] <span class="keyword">for</span> n <span class="keyword">in</span> range(n)]</span><br><span class="line"><span class="comment">#我们并不在意一个Vertex自己到自己的情况, 比如[1][1]的情况.可以保留0.</span></span><br><span class="line">adj_matrix[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">adj_matrix[<span class="number">1</span>][<span class="number">2</span>] = <span class="number">1</span></span><br><span class="line">adj_matrix[<span class="number">1</span>][<span class="number">3</span>] = <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>从这个很小的例子上可以看出, 因为可以直接访问index, 它可以很方便的存储信息而且对称.</p>
<ul>
<li>所需空间: n^2. </li>
<li>检查某两个vertex之间是否有edge需要O(1)的时间</li>
<li>已知这样的一个matrix, 获得所有edge信息所需要的时间也是O(n^2). 因为要把这个二维数组扫一遍.</li>
<li>如果是无向图(Undirected graph)的话只需要填写一半的空间, 或者可以这么说, 每当写入 <code>[A][B]=1</code> 的时候也写入 <code>[B][A]=1</code>. 这样出来的matrix应该是沿着对角线对称的.</li>
</ul>
<p><strong>Adjacency List</strong></p>
<p>比较经典的例子就是用dictionary/map来存所有的vertex作为key, 存储的值为每个vertex的neighbour.<br>同样的图拿来做例子:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">V = &#123;0,1,2,3&#125;</span><br><span class="line">E = &#123;0-1, 1-2, 1-3&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">adj_list = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> vertex <span class="keyword">in</span> V:</span><br><span class="line">    adj_list[vertex] = []</span><br><span class="line"><span class="keyword">for</span> edge <span class="keyword">in</span> E:</span><br><span class="line">    origin = edge[<span class="number">0</span>] </span><br><span class="line">    destination = edge[<span class="number">1</span>]</span><br><span class="line">    <span class="comment">#假设所有的edge都是合法的, 不会出现刚才V list之外的起点/终点</span></span><br><span class="line">    adj_list[origin].append(destination)</span><br></pre></td></tr></table></figure>
<p>这样产生的adj_list将会是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    0:[1],</span><br><span class="line">    1:[2,3],</span><br><span class="line">    2:[]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>所需空间: m + n (edge个数 + vertex个数) </li>
<li>检查某两个vertex之间是否有edge, 需要O(degree of vertex)的时间.</li>
</ul>
<p>比如我们想求vertex 1, 0之间有没有一条边. origin是1, destination是0. </p>
<p>那么我们需要通过这个字典O(1)时间找到1这个key存储邻居用的list.<br>因为这里用了list来村邻居, 所以找到destination需要的时间是这个key<strong>所有的邻居个数</strong> 也就是<strong>degree of vertex</strong>. </p>
<p>这个例子里, 1有两个邻居, 2和3. 找到了底也没有发现0, 所以可以返回有或者没有这条边的结论.</p>
<ul>
<li>已知这样的一个matrix, 获得所有edge信息所需要的时间也是O(n^2). 因为要把这个二维数组扫一遍.</li>
</ul>
<h2 id="重要算法"><a href="#重要算法" class="headerlink" title="重要算法"></a>重要算法</h2><p>我们主要来解决lecture提出的三个问题:</p>
<ol>
<li>s-t connectivity problem. 在我们知道s,t这两个点之后, 如何确定s和t之间可以联得通(有path)?</li>
<li>length of path. 这条path有多长?</li>
<li>s-t shortest path problem. s到t最短的路是什么呢? 如果路有权重的情况下又如何呢?</li>
</ol>
<p>书上给的算法例子其实有更加简洁的写法.</p>
<p>以下的例子均为以adjacecy matrix 实现的图.</p>
<h3 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h3><p>BFS适合拿来解决的问题包括:</p>
<pre><code>1. 无权重的最短路径
2. 从一个vertex可以到达的所有其他点
3. 需要由近及远的一层层的traverse一个图的问题. 比如获取从当前vertex到其他vertex需要走几步.
</code></pre><p><strong>BFS模板</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># assume Graph is an adjacency list implemented by dictionary &amp; list.</span></span><br><span class="line">V = Graph.keys()</span><br><span class="line"></span><br><span class="line"><span class="comment"># start from node 0.</span></span><br><span class="line">start = V[<span class="number">0</span>]</span><br><span class="line">queue = [start]</span><br><span class="line">visited = set(queue)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(queue): </span><br><span class="line">    current_vertex = queue.pop(<span class="number">0</span>)</span><br><span class="line">    <span class="comment">#这一步对每一个vertex会发生一次, 一共会发生N次</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># do something to current node</span></span><br><span class="line"></span><br><span class="line">    neighbours = Graph[current_vertex] <span class="comment">#neighbours of current vertex </span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> neighbours: <span class="comment">#这个循环会探查从这个vertex出去的所有edge, 全局来看一共会发生M次.</span></span><br><span class="line">        <span class="keyword">if</span> n <span class="keyword">not</span> <span class="keyword">in</span> visited: <span class="comment">#注意检查是否已经visit过, 否则会死循环</span></span><br><span class="line">            queue.append(n)</span><br><span class="line">            visited.add(current_vertex) <span class="comment">#加入已visited</span></span><br></pre></td></tr></table></figure>
<p>同时,这个模板解决的问题是”Find all nodes reachable from S”. 结束这个模板之后的visited set将会含有所有从s可以到达的vertex</p>
<ul>
<li>无权重的shorest path问题</li>
</ul>
<p>解决从s到t最短需要经过几条edge的问题, (不需要记录路径), 对bfs稍作改动即可.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># assume Graph is an adjacency list implemented by dictionary &amp; list.</span></span><br><span class="line">V = Graph.keys()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> v <span class="keyword">in</span> V:</span><br><span class="line">    distance[v] = <span class="number">0</span></span><br><span class="line"><span class="comment"># start from node 0.</span></span><br><span class="line">start = V[<span class="number">0</span>]</span><br><span class="line">queue = [start]</span><br><span class="line">visited = set([start])</span><br><span class="line">distance = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(queue): </span><br><span class="line">    current_vertex = queue.pop(<span class="number">0</span>)</span><br><span class="line">     <span class="comment">#这一步对每一个vertex会发生一次, 一共会发生N次</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># do something to current node</span></span><br><span class="line"></span><br><span class="line">    neighbours = Graph[current_vertex] <span class="comment">#neighbours of current vertex </span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> neighbours: <span class="comment">#这个循环会探查从这个vertex出去的所有edge, 全局来看一共会发生M次.</span></span><br><span class="line">        <span class="keyword">if</span> n <span class="keyword">not</span> <span class="keyword">in</span> visited: <span class="comment">#注意检查是否已经visit过, 否则会死循环</span></span><br><span class="line">            queue.append(n)</span><br><span class="line">            distance[n] = distance[current_vertex]+<span class="number">1</span> </span><br><span class="line">            <span class="comment"># neighbour与起点的距离, 比current vertex与起点的距离多1 因为我们先遇到了current vertex</span></span><br><span class="line">            visited.add(n)</span><br><span class="line">        <span class="keyword">if</span> n==end:</span><br><span class="line">            <span class="keyword">return</span> distance[end]</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> float(<span class="string">'inf'</span>)</span><br></pre></td></tr></table></figure>
<p>以上的模板只能告诉大家最短路是多长.</p>
<p>如果需要记录从S到T的路径的话, 我们需要另外的空间来存每一个vertex的前置位, 这样就可以在发现终点之后根据前置位的信息, 一路trace回起点.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">V = Graph.keys()</span><br><span class="line"></span><br><span class="line"><span class="comment"># start from node 0.</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bfs_return_path</span><span class="params">(start, end, Graph)</span>:</span></span><br><span class="line">    queue = [start]</span><br><span class="line">    visited = set([start])</span><br><span class="line">    prev = &#123;start:<span class="keyword">None</span>&#125; <span class="comment">#我们设start的前置位是空的</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_path</span><span class="params">(end, prev)</span>:</span></span><br><span class="line">        path = []</span><br><span class="line">        <span class="keyword">while</span>(end!=<span class="keyword">None</span>):</span><br><span class="line">            path.append(end)</span><br><span class="line">            end = prev[end]</span><br><span class="line"></span><br><span class="line">        path.reverse()</span><br><span class="line">        <span class="keyword">return</span> path</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(queue): </span><br><span class="line">        current_vertex = queue.pop(<span class="number">0</span>)</span><br><span class="line">        neighbours = Graph[current_vertex] </span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> neighbours: </span><br><span class="line">            <span class="keyword">if</span> n <span class="keyword">not</span> <span class="keyword">in</span> visited: </span><br><span class="line">                queue.append(n)</span><br><span class="line">                prev[n] = current_vertex </span><br><span class="line">                <span class="comment">#这一步来记录前置位.</span></span><br><span class="line">                <span class="comment">#neighbour的前置位是current v. 因为我们先遇到current v,再遇到neighbour</span></span><br><span class="line">                visited.add(n) </span><br><span class="line">            <span class="keyword">if</span> n==end:</span><br><span class="line">                print(prev)</span><br><span class="line">                <span class="keyword">return</span>(get_path(end, prev))</span><br><span class="line">                </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> [] <span class="comment"># 找不到终点, 返回空</span></span><br></pre></td></tr></table></figure>
<p></p>
<h2 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h2><p>DFS适合拿来解决的问题包括:</p>
<pre><code>1. 从一个vertex可以到达的所有其他点
2. 搜索, Backtracking类型的问题, 比如print all path between S to T.
3. 图是否有cycle
</code></pre><p><strong>DFS递归模板</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># assume Graph is an adjacency list implemented by dictionary &amp; list.</span></span><br><span class="line">V = Graph.keys()</span><br><span class="line">start = V[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">visited = set()</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(current_vertex, graph, visited)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> node <span class="keyword">in</span> visited: <span class="comment">#检查是否已经visit过</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="comment"># do something to visit</span></span><br><span class="line">    visited.add(current_vertex)</span><br><span class="line">    neighbours = Graph[current_vertex] <span class="comment">#neighbours of current vertex</span></span><br><span class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> neighbours:</span><br><span class="line">        dfs(n, graph, visited)</span><br></pre></td></tr></table></figure></p>
<ul>
<li>Level Order Traversal</li>
<li></li>
</ul>
<p><strong>DFS非递归模板</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># assume Graph is an adjacency list implemented by dictionary &amp; list.</span></span><br><span class="line">V = Graph.keys()</span><br><span class="line"></span><br><span class="line"><span class="comment"># start from node 0.</span></span><br><span class="line">start = V[<span class="number">0</span>]</span><br><span class="line">queue = [start]</span><br><span class="line">visited = set()</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(queue): </span><br><span class="line">    current_vertex = queue.pop() </span><br><span class="line">    <span class="comment">#注意这里用的是pop() 而非pop(0). 与BFS模板唯一的区别在于, DFS优先探索栈尾.</span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># do something to current node</span></span><br><span class="line">    neighbours = Graph[current_vertex] <span class="comment">#neighbours of current vertex </span></span><br><span class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> neighbours:</span><br><span class="line">        <span class="keyword">if</span> n <span class="keyword">not</span> <span class="keyword">in</span> visited: <span class="comment">#注意检查是否已经visit过, 否则会死循环</span></span><br><span class="line">            queue.append(n)</span><br><span class="line">            visited.add(current_vertex)</span><br></pre></td></tr></table></figure></p>
<ul>
<li><p><strong>Run time analysis</strong></p>
<ul>
<li>对于adjacency list的实现方法, BFS和DFS都需要O(m+n)的时间.</li>
</ul>
</li>
<li><p>DFS和BFS的优势和劣势</p>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/23/Intro_dp/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Shirley Hou">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Shirley's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/23/Intro_dp/" itemprop="url">DP intro</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-12-23T13:07:40+11:00">
                2018-12-23
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/刷题/" itemprop="url" rel="index">
                    <span itemprop="name">刷题</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>DP, 3027的重点.</p>
<p>入门章节 </p>
<p><strong>学完并熟练掌握INFO1105/数据结构的同学可以跳过这篇.</strong></p>
<h2 id="Fibonacci"><a href="#Fibonacci" class="headerlink" title="Fibonacci"></a>Fibonacci</h2><p>我们回忆一下INFO1110里讲过的递归寻找斐波那契数列的问题</p>
<p>斐波那契数列的递归定义如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">F(0) = 0</span><br><span class="line">F(1) = 1</span><br><span class="line">F(n) = F(n-1)+F(n-2)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">用文字来说，就是费波那契数列由0和1开始，之后的费波那契系数就是由之前的两数相加而得出。</span><br><span class="line">从第0项开始的费波那契系数是：</span><br><span class="line"></span><br><span class="line">0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233…</span><br></pre></td></tr></table></figure>
<p>如果用递归的方法来写找第N个斐波那契数, 非常简单直接<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fibonacci</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> n==<span class="number">0</span> <span class="keyword">or</span> n==<span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> fibonacci(n<span class="number">-1</span>) + fibonacci(n<span class="number">-2</span>)</span><br></pre></td></tr></table></figure></p>
<p>请自己试一试, 在你的电脑上找<code>fibonacci(50)</code> 大概需要多久?</p>
<hr>
<p>我猜基本上你没耐心等到50 :D</p>
<p>有没有更快的办法呢?</p>
<p>首先我们来看一看为什么这个fibonaaci要跑这么久.</p>
<p>举一个简单的例子, 我们要算 f(5), 我们数一下有几次操作.<br>对于递归内部, 假设每次我们都先展开计算左边那半部分.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">f(5) = f(4) + f(3)</span><br><span class="line">f(4) = f(3) + f(2)</span><br><span class="line">f(3) = f(2) + f(1)</span><br><span class="line">f(2) = f(1) + f(0)</span><br><span class="line">f(1) = 1 return</span><br><span class="line">f(0) = 0 return</span><br><span class="line">f(2) = 1 + 0 = 2 return</span><br><span class="line">f(3) = 2 + f(1)</span><br><span class="line">f(1) = 1 return</span><br><span class="line">f(3) = 2 + 1 = 3 return</span><br><span class="line">f(4) = 3 + f(2)</span><br><span class="line">f(2) = f(1) + f(0)</span><br><span class="line">f(1) = 1 return</span><br><span class="line">f(0) = 0 return</span><br><span class="line">f(2) = 1 + 0 = 2 return</span><br><span class="line">f(4) = 3 + 2 = 5 return</span><br><span class="line">f(5) = 5 + f(3)</span><br><span class="line">f(3) = f(2) + f(1)</span><br><span class="line">f(2) = f(1) + f(0)</span><br><span class="line">f(1) = 1 return</span><br><span class="line">f(0) = 0 return</span><br><span class="line">f(2) = 1 + 0 = 2 return</span><br><span class="line">f(3) = 2 + f(1)</span><br><span class="line">f(1) = 1 return</span><br><span class="line">f(3) = 2 + 1 = 3 return</span><br><span class="line">f(5) = 5 + 3 = 8 return</span><br></pre></td></tr></table></figure></p>
<p>有没有发现我们中间重复计算了很多次f(3), f(2), f(1), f(0)的部分呢?</p>
<p>实际上, 由于我们求过了f(3), f(2), f(1), f(0), 却没有把这些值保存下来, 这导致了递归版本的斐波那契数列的运行时间是指数级别的. </p>
<p>为什么是O(2^n)呢? 很显然, f(n) = f(n-1) + f(n-2). 如果计算f(n+1) = f(n) + f(n-1). 则f(n), 包括f(n-1)的部分都要被重复计算. 精确的来说, 斐波那契数列的复杂度是 1.618^n, 黄金分割比值.</p>
<p>下面我们来介绍一下动态规划思想.</p>
<p>首先, 它所做的是”把算过的东西存起来”.</p>
<p>但这门课中最重要的是, 利用它来拆分复杂的数学问题.</p>
<ol>
<li><p>首先，我们要找到某个子问题的最优解，然后在它的帮助下，找到下一个状态的最优解。</p>
</li>
<li><p>通常许多子问题非常相似，为此动态规划法试图<strong>仅仅解决每个子问题一次</strong>，从而减少计算量. 一旦某个给定子问题的解已经算出，则将其记忆化<strong>存储</strong>，以便下次需要同一个子问题解之时<strong>直接查表</strong>.</p>
</li>
</ol>
<p>目前, 我们至少可以做到”把算过的东西存起来”.</p>
<p>如何存? 怎么查表? 不妨自己试试.(下面也有答案)</p>
<h2 id="台阶问题"><a href="#台阶问题" class="headerlink" title="台阶问题"></a>台阶问题</h2><p>理解了斐波那契问题之后, 来试一试非常相似的一道台阶问题吧!</p>
<h2 id="Leetcode-70-Climbing-Stairs"><a href="#Leetcode-70-Climbing-Stairs" class="headerlink" title="Leetcode 70 Climbing Stairs"></a>Leetcode 70 Climbing Stairs</h2><p><a href="https://leetcode.com/problems/climbing-stairs/" target="_blank" rel="noopener">原题链接</a></p>
<h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>你有一个N个台阶的梯子, 你可以一次走两格或者一次走一格.<br>一共有几种走法?</p>
<p>比如说一个这样的例子:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: 3</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: There are three ways to climb to the top.</span><br><span class="line">1. 1 step + 1 step + 1 step</span><br><span class="line">2. 1 step + 2 steps</span><br><span class="line">3. 2 steps + 1 step</span><br></pre></td></tr></table></figure>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>没有头绪的时候, 首先思考一下base case.</p>
<p>如果我们一个台阶都没有? 那就没有走法了. return 0.<br>我们如果只有一个台阶, 那就只能有一种走法, 走一格.<br>我们如果只有2个台阶, 那就只能有2种走法, 两次一格, 或者, 一次2格.</p>
<p>如果我们有三个台阶呢?<br>不妨想一想, 我们是如何到台阶3的? </p>
<p>我们既然一次只能走两格或者一格, 那说明上一步我们要么在台阶1 要么在台阶2.</p>
<p>这样是不是就豁然开朗了一些?<br>我到台阶3的走法, 是我到台阶2的走法, 与台阶1的走法之和.</p>
<p>这个问题的子问题与递推关系式, 恰好就和斐波那契数列一样:<br>f(n) = f(n-1) + f(n-2).</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">climbStairs</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> n&lt;=<span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> n</span><br><span class="line">        p=[<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(n+<span class="number">1</span>)]</span><br><span class="line">        p[<span class="number">0</span>]=<span class="number">0</span></span><br><span class="line">        p[<span class="number">1</span>]=<span class="number">1</span></span><br><span class="line">        p[<span class="number">2</span>]=<span class="number">2</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>,n+<span class="number">1</span>):</span><br><span class="line">                p[i] = p[i<span class="number">-1</span>]+p[i<span class="number">-2</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> p[n]</span><br></pre></td></tr></table></figure>
<h3 id="动态规划所适用的情况"><a href="#动态规划所适用的情况" class="headerlink" title="动态规划所适用的情况"></a>动态规划所适用的情况</h3><p>(摘自维基百科)</p>
<ol>
<li><strong>最优子结构</strong>. 如果问题的最优解所包含的子问题的解也是最优的，我们就称该问题具有最优子结构性质（即满足最优化原理）。最优子结构性质为动态规划算法解决问题提供了重要线索。</li>
</ol>
<p>比如, 在爬台阶的问题里, 可以这么理解:<br>如果我想知道第N个斐波那契数, 我必然会求解第N-1和第N-2个斐波那契数.<br>不会存在我求第N个的时候, 所使用的N-2与N-1并不等同于N-2与N-1的最优解.</p>
<ol start="2">
<li><strong>无后效性</strong>. 即子问题的解一旦确定，就不再改变，不受在这之后、包含它的更大的问题的求解决策影响。</li>
</ol>
<p>结合上一条一起理解, 就是所有的子问题都可以安全的用相同的递推公式.</p>
<ol start="3">
<li><strong>子问题重叠性质</strong>. 子问题重叠性质是指在用递归算法自顶向下对问题进行求解时，每次产生的子问题并不总是新问题，有些子问题会被重复计算多次。动态规划算法正是利用了这种子问题的重叠性质，对每一个子问题只计算一次，然后将其计算结果保存在一个表格中，当再次需要计算已经计算过的子问题时，只是在表格中简单地查看一下结果，从而获得较高的效率.</li>
</ol>
<p>这就是”把算过的部分存起来”的概念.</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/16/dp_best_time_stock_series/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Shirley Hou">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Shirley's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/16/dp_best_time_stock_series/" itemprop="url">Best time to buy and sell stock 系列</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-12-16T19:23:56+11:00">
                2018-12-16
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/刷题/" itemprop="url" rel="index">
                    <span itemprop="name">刷题</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>这套老经典了, 有六道题, 从Greedy做到DP.</p>
<p>分别是:</p>
<ul>
<li>121 Best Time to Buy and Sell Stock</li>
<li>122 Best Time to Buy and Sell Stock II</li>
<li>123 Best Time to Buy and Sell Stock III</li>
<li>188 Best Time to Buy and Sell Stock IV</li>
<li>122 Best Time to Buy and Sell Stock with cool down</li>
<li>714 Best Time to Buy and Sell Stock with transaction fee</li>
</ul>
<h2 id="121-Best-Time-to-Buy-and-Sell-Stock"><a href="#121-Best-Time-to-Buy-and-Sell-Stock" class="headerlink" title="121. Best Time to Buy and Sell Stock"></a>121. Best Time to Buy and Sell Stock</h2><p><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock/" target="_blank" rel="noopener">原题链接</a></p>
<h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>这个function的input是个<code>int</code>一位数组, 每一位代表当天的股票价格. </p>
<p>我们的目的是在仅仅能交易一次的情况下最大化收益. 求最大的收益.</p>
<p>举例:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [7,1,5,3,6,4]</span><br><span class="line">Output: 5</span><br><span class="line">Explanation: 第二天买入第五天卖出, profit = 6-1 = 5.</span><br></pre></td></tr></table></figure></p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>这是一个Easy的贪心问题. </p>
<p>我们的目的就是找到整个价格波动中的’最高点’和’最低点’,只要这个’最高点’发生在’最低点’之后就可以被考虑了.</p>
<p>直观需要画图: (leetcode的原图)<br><img src="images/121_profit_graph.png" alt="121_profit_graph"></p>
<p>这里的’最低点’是第二天, ‘最高点’是第五天</p>
<p>这里用one pass才能过. 还是有一点点小tricky的.</p>
<p>one pass就是每一天扫过来, 更新记录过的最小价格<code>min_price</code>, <strong>或者</strong>用当天价格去减去记录中的<code>min_price</code>, 就是以当天为截止日期的最好收益<code>max_profit</code>. (也有点dp的意味在里面啊!) </p>
<p><strong>为什么可以这样one pass呢? </strong></p>
<p>如果某天的价格更新了最低, 这个更新只会影响到它之后的收益计算. 恰好和题意相符合. </p>
<p>需要非常注意一点就是以上步骤的加粗<strong>或者</strong>很重要, 因为我们不能再在同一天买进卖出, 更新了<code>min_price</code>就不可以更新<code>max_profit</code>.</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type prices: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> len(prices)==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        opt = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> prices]</span><br><span class="line">        max_profit= <span class="number">0</span></span><br><span class="line">        min_price = float(<span class="string">'inf'</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> prices:</span><br><span class="line">            <span class="keyword">if</span> i &lt; min_price:</span><br><span class="line">                min_price= i</span><br><span class="line">            <span class="keyword">elif</span> i-min_price&gt;max_profit: <span class="comment">#can't buy sell on same day</span></span><br><span class="line">                max_profit = max(i-min_price, max_profit)</span><br><span class="line">                </span><br><span class="line">        <span class="keyword">return</span> max_profit</span><br></pre></td></tr></table></figure>
<h3 id="Submission-Detail"><a href="#Submission-Detail" class="headerlink" title="Submission Detail"></a>Submission Detail</h3><p>40ms, 99.98%.</p>
<h2 id="122-Best-Time-to-Buy-and-Sell-Stock-II"><a href="#122-Best-Time-to-Buy-and-Sell-Stock-II" class="headerlink" title="122. Best Time to Buy and Sell Stock II"></a>122. Best Time to Buy and Sell Stock II</h2><p><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/" target="_blank" rel="noopener">原题链接</a></p>
<h3 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h3><p>和上一题一样, 这个function的input是个<code>int</code>数组, 代表每天的股票价格. </p>
<p>与上一题有所不同的是, 我们可以交易无限多次. 依旧是不能同一天买进卖出. </p>
<p>求最大的收益.</p>
<p>举例:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: [7,1,5,3,6,4]</span><br><span class="line">Output: 7</span><br><span class="line">Explanation: 第二天买进第三天卖出, profit = 5-1 = 4.</span><br><span class="line">             第四天买进第五天卖出, profit = 6-3 = 3.</span><br></pre></td></tr></table></figure></p>
<h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>这是一个Easy的贪心问题. 比上一题还要直观.</p>
<p>想一下以下几种情况:<br>[1,2,3,4,5]. 持续增长的价格, 最好第一天最后一天再卖. 如果中间有买卖行为则亏了, 因为不能同时买卖.</p>
<p>[5,4,3,2,1]. 持续跌的价格, 和上题一样, 不要进行任何买卖.</p>
<p>[1,3,3,3,3,6]. 中间有平台的价格, 第一天买最后一天卖的收益 和在平台期进行买卖, 效果一样. </p>
<p>[1,3,2,4,3,5]. 这种情况则收入是2*3 = 6 (第一天买第二天卖第三天买第四天卖..), 比第一天买最后一天卖来的多. </p>
<p>这几个例子可以说明要充分利用每一次价格波动的时候买卖.平台则没有影响.</p>
<p>假设<code>[n0..min, n1, n2,...max, n3..]</code>的情况, 则中间但凡有<code>(n1-n2) &gt; 0</code>, 那<code>(n1 - min) + (max - n2) = (max - min) + (n1 - n2) &gt; (max - min)</code>, 都比只在<code>min</code>和<code>max</code>之间交易来得好.</p>
<p>所以, 只要是但凡今天的价格比昨天高, 我们就继续按住不卖(中间不要买卖, 因为在连续升值中间买卖会亏), 直到出现平台或者跌价, 则再次马上买进.</p>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type prices: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment">#this is a greedy approach: we add on profit whenever day &gt; day-1.</span></span><br><span class="line">        n = len(prices)</span><br><span class="line">        <span class="keyword">if</span> n&lt;=<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        total_profit = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> prices[i]-prices[i<span class="number">-1</span>]&gt;<span class="number">0</span>:</span><br><span class="line">                total_profit+=prices[i]-prices[i<span class="number">-1</span>]</span><br><span class="line">            <span class="comment">#这里的一直hold住, 直到跌价就卖出, 有点抽象. 体会一下.</span></span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> total_profit</span><br></pre></td></tr></table></figure>
<h3 id="Submission-Detail-1"><a href="#Submission-Detail-1" class="headerlink" title="Submission Detail"></a>Submission Detail</h3><p>44ms, 85.98%.</p>
<h2 id="123-Best-Time-to-Buy-and-Sell-Stock-III-188-Best-Time-to-Buy-and-Sell-Stock-IV"><a href="#123-Best-Time-to-Buy-and-Sell-Stock-III-188-Best-Time-to-Buy-and-Sell-Stock-IV" class="headerlink" title="123 Best Time to Buy and Sell Stock III, 188 Best Time to Buy and Sell Stock IV"></a>123 Best Time to Buy and Sell Stock III, 188 Best Time to Buy and Sell Stock IV</h2><p><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/" target="_blank" rel="noopener">123: 原题链接</a></p>
<p><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/" target="_blank" rel="noopener">188: 原题链接</a></p>
<h3 id="描述-2"><a href="#描述-2" class="headerlink" title="描述"></a>描述</h3><p>input是个<code>int</code>数组, 代表每天的股票价格. </p>
<p>与上一题有所不同的是, Best Time to Buy and Sell Stock IV里我们最多可以交易k次.<br>Best Time to Buy and Sell Stock III是这个问题的一个子集. k=2次.</p>
<p>求最大的收益.</p>
<p>举例:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: [3,2,6,5,0,3], k = 2</span><br><span class="line">Output: 7</span><br><span class="line">Explanation: 第二天买入第三天卖出, profit = 6-2 = 4.</span><br><span class="line">             第五天买入第六天卖出, profit = 3-0 = 3.</span><br></pre></td></tr></table></figure></p>
<h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>这是一个DP典型背包问题, 有k次选择机会(对应背包中的volume限制), 求最大化的价值.<br>背包里的物品对应执行一次买进卖出的行为.<br>可以由以下方程概括:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dp[i][x] = max( dp[i<span class="number">-1</span>][x] , <span class="comment">#不进行买卖, 可用选择机会不变</span></span><br><span class="line">                dp[j][x – <span class="number">1</span>] + prices[i] – prices[j] <span class="comment">#进行买卖, 需要loop背包矩阵上一排从0到i的最优解 求最大值</span></span><br><span class="line">              ), <span class="keyword">for</span> all j &lt; i.</span><br></pre></td></tr></table></figure></p>
<p>然而这样子写是TLE了.</p>
<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><p>直观的背包: TLE<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, k, prices)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :type prices: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        dp[i][x] = max(dp[i-1][x] , dp[j][x – 1] + prices[i] – prices[j]) for all j &lt; i.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        n = len(prices)</span><br><span class="line">        <span class="keyword">if</span> n&lt;=<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        dp=[[<span class="number">0</span> <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>,k+<span class="number">1</span>)] <span class="keyword">for</span> i <span class="keyword">in</span> range(n)]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,n):  </span><br><span class="line">            <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">1</span>,k+<span class="number">1</span>):</span><br><span class="line">                max_counter = <span class="number">0</span></span><br><span class="line">                </span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>, i):</span><br><span class="line">                    diff = prices[i]-prices[j]</span><br><span class="line">                    max_counter = max(max_counter,dp[j][x<span class="number">-1</span>]+diff) </span><br><span class="line">                    </span><br><span class="line">                dp[i][x]=max(dp[i<span class="number">-1</span>][x],max_counter)</span><br><span class="line">                </span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">-1</span>][<span class="number">-1</span>]</span><br></pre></td></tr></table></figure></p>
<p><strong>改良的背包</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, k, prices)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :type prices: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        global[i][j]=max(local[i][j],global[i-1][j])</span></span><br><span class="line"><span class="string">        local[i][j]=max(global[i-1][j-1]+max(diff,0),local[i-1][j]+diff)</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        n = len(prices)</span><br><span class="line">        <span class="keyword">if</span> n&lt;=<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> k&lt;n//<span class="number">2</span>:</span><br><span class="line">            Local=[<span class="number">0</span> <span class="keyword">for</span> j <span class="keyword">in</span> range(k+<span class="number">1</span>)]</span><br><span class="line">            Global=[<span class="number">0</span> <span class="keyword">for</span> j <span class="keyword">in</span> range(k+<span class="number">1</span>)]</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,n):</span><br><span class="line">                diff = prices[i]-prices[i<span class="number">-1</span>] <span class="comment">#这里用回之前的逻辑,只要不跌价就一直怼</span></span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> range(k, <span class="number">0</span>,<span class="number">-1</span>):</span><br><span class="line">                    Local[j]=max(Global[j<span class="number">-1</span>]+max(diff,<span class="number">0</span>),Local[j]+diff)</span><br><span class="line">                    Global[j]=max(Local[j],Global[j])</span><br><span class="line">            <span class="keyword">return</span> Global[<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            total_profit = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">                diff = prices[i]-prices[i<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> diff&gt;<span class="number">0</span>:</span><br><span class="line">                    total_profit+=diff</span><br><span class="line">            <span class="keyword">return</span> total_profit</span><br></pre></td></tr></table></figure>
<h3 id="Submission-Detail-2"><a href="#Submission-Detail-2" class="headerlink" title="Submission Detail"></a>Submission Detail</h3><p>172 ms, 21.46%.</p>
<h2 id="309-Best-Time-to-Buy-and-Sell-Stock-with-Cooldown-714-Best-Time-to-Buy-and-Sell-Stock-with-transaction-fee"><a href="#309-Best-Time-to-Buy-and-Sell-Stock-with-Cooldown-714-Best-Time-to-Buy-and-Sell-Stock-with-transaction-fee" class="headerlink" title="309. Best Time to Buy and Sell Stock with Cooldown, 714. Best Time to Buy and Sell Stock with transaction fee"></a>309. Best Time to Buy and Sell Stock with Cooldown, 714. Best Time to Buy and Sell Stock with transaction fee</h2><p><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/" target="_blank" rel="noopener">309: 原题链接</a></p>
<p><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/" target="_blank" rel="noopener">714: 原题链接</a></p>
<h3 id="代码-309-with-transaction-fee"><a href="#代码-309-with-transaction-fee" class="headerlink" title="代码: 309 (with transaction fee)"></a>代码: 309 (with transaction fee)</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type prices: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment">#依旧尽量多的买卖.所以至多是i-1 i-2的关系</span></span><br><span class="line">        <span class="comment">#如果前一天sell 今天就需要作废 不能用作买进</span></span><br><span class="line">        <span class="comment">#如果前一天没有sell 今天可以用作买进</span></span><br><span class="line">        <span class="comment">#buy[i] = max(sell[i-2]-prices[i], buy[i-1])</span></span><br><span class="line">        <span class="comment">#sell[i]=max(buy[i-1]+prices[i]买入, sell[i-1]不买)</span></span><br><span class="line">        n=len(prices)</span><br><span class="line">        <span class="keyword">if</span> n&lt;=<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">elif</span> n==<span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> max(<span class="number">0</span>, prices[<span class="number">1</span>]-prices[<span class="number">0</span>])</span><br><span class="line">        total_profit = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        buy=[<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(n)]</span><br><span class="line">        sell=[<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(n)]</span><br><span class="line">        buy[<span class="number">0</span>]=-prices[<span class="number">0</span>]</span><br><span class="line">        buy[<span class="number">1</span>]=max(-prices[<span class="number">0</span>], -prices[<span class="number">1</span>])</span><br><span class="line">        sell[<span class="number">1</span>]=max(<span class="number">0</span>,buy[<span class="number">0</span>]+prices[<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>,n):</span><br><span class="line">            buy[i] = max(sell[i<span class="number">-2</span>]-prices[i], buy[i<span class="number">-1</span>])</span><br><span class="line">            sell[i]= max(buy[i<span class="number">-1</span>]+prices[i], sell[i<span class="number">-1</span>])</span><br><span class="line">                </span><br><span class="line">        <span class="comment">#print(sell, buy)</span></span><br><span class="line">        <span class="keyword">return</span> sell[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>
<h3 id="代码-714-with-transaction-fee"><a href="#代码-714-with-transaction-fee" class="headerlink" title="代码: 714 (with transaction fee)"></a>代码: 714 (with transaction fee)</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices, fee)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type prices: List[int]</span></span><br><span class="line"><span class="string">        :type fee: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        和309基本就是照抄, 对每一天来说可以买入或者不买</span></span><br><span class="line"><span class="string">        买入一次就需要-fee</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        n=len(prices)</span><br><span class="line">        <span class="keyword">if</span> n&lt;=<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        buy=[<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(n)]</span><br><span class="line">        sell=[<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(n)]</span><br><span class="line">        buy[<span class="number">0</span>]=-prices[<span class="number">0</span>]</span><br><span class="line">        sell[<span class="number">1</span>]=max(<span class="number">0</span>,buy[<span class="number">0</span>]+prices[<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,n):</span><br><span class="line">            buy[i] = max(sell[i<span class="number">-1</span>]-prices[i], buy[i<span class="number">-1</span>])</span><br><span class="line">            sell[i]= max(buy[i<span class="number">-1</span>]+prices[i]-fee, sell[i<span class="number">-1</span>])</span><br><span class="line">        <span class="keyword">return</span> sell[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/09/Warmup_dp/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Shirley Hou">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Shirley's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/09/Warmup_dp/" itemprop="url">DP热身问题 (Leetcode)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-12-09T17:20:19+11:00">
                2018-12-09
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/刷题/" itemprop="url" rel="index">
                    <span itemprop="name">刷题</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>DP, 3027的重点.</p>
<p>需要反复暴露在不同的题型下才能触类旁通的类型.<br>这是热身的章节.<br>DP概念入门</p>
<h2 id="Leetcode-256-Paint-House"><a href="#Leetcode-256-Paint-House" class="headerlink" title="Leetcode 256 Paint House"></a>Leetcode 256 Paint House</h2><p>Leet上的入门DP问题<br><a href="https://leetcode.com/problems/paint-house/" target="_blank" rel="noopener">原题链接</a></p>
<h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>有一排N个房子，可以用红绿蓝三色来涂，有一个COST[N][0:2]的信息分别表示在画第N个房子时红绿蓝分别的价格。<br>要求是相邻两个房子不能一样颜色。<br>求画到第N个房子的最低总价格.</p>
<p>比如说一个这样的例子:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: [[17,2,17],[16,16,5],[14,3,19]]</span><br><span class="line">    价格:(红0蓝0绿0)(红1蓝1绿1)(红2蓝2绿2)</span><br><span class="line"></span><br><span class="line">Output: 10</span><br><span class="line">Explanation: 选择这样的涂法: 第0个房子是蓝色, 第1个房子绿色, 第2个房子蓝色.</span><br><span class="line">             这样的总价格是 2 + 5 + 3 = 10. 是所有可能性里最小的.</span><br></pre></td></tr></table></figure>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>在画第i个房子时候, 假设这一格要选红房子, 总价格为 <code>min[前一格(i-1)是绿格子的总价格，前一格(i-1)是蓝房子的总价格] + 这一格红房子的价格</code><br>那到了第N个房子, 最低价格就是红蓝绿里最低那个了.</p>
<p>需要开 OPT[3][N] 来存RGB分别在画第N个房子时的最低价格</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">updateOPT</span><span class="params">(self, OPT, i, costs)</span>:</span></span><br><span class="line">        <span class="comment">#if color = 'r':</span></span><br><span class="line">        OPT[<span class="number">0</span>][i]=min(OPT[<span class="number">1</span>][i<span class="number">-1</span>],OPT[<span class="number">2</span>][i<span class="number">-1</span>])+costs[i][<span class="number">0</span>]</span><br><span class="line">        <span class="comment">#elif color = 'b':</span></span><br><span class="line">        OPT[<span class="number">1</span>][i]=min(OPT[<span class="number">0</span>][i<span class="number">-1</span>],OPT[<span class="number">2</span>][i<span class="number">-1</span>])+costs[i][<span class="number">1</span>]</span><br><span class="line">        <span class="comment">#elif color = 'g':</span></span><br><span class="line">        OPT[<span class="number">2</span>][i]=min(OPT[<span class="number">0</span>][i<span class="number">-1</span>],OPT[<span class="number">1</span>][i<span class="number">-1</span>])+costs[i][<span class="number">2</span>]</span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minCost</span><span class="params">(self, costs)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type costs: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment">#No two houses are painted with the same color</span></span><br><span class="line">        <span class="comment">#target: total price is lowest</span></span><br><span class="line">        </span><br><span class="line">        N = len(costs)</span><br><span class="line">        <span class="keyword">if</span> N==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> len(costs[<span class="number">0</span>])==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        OPT= [[<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(N)] <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>)]</span><br><span class="line">        OPT[<span class="number">0</span>][<span class="number">0</span>]=costs[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">        OPT[<span class="number">1</span>][<span class="number">0</span>]=costs[<span class="number">0</span>][<span class="number">1</span>]</span><br><span class="line">        OPT[<span class="number">2</span>][<span class="number">0</span>]=costs[<span class="number">0</span>][<span class="number">2</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,N):</span><br><span class="line">            self.updateOPT(OPT, i, costs)</span><br><span class="line">        <span class="keyword">return</span> min(OPT[<span class="number">0</span>][N<span class="number">-1</span>], OPT[<span class="number">1</span>][N<span class="number">-1</span>], OPT[<span class="number">2</span>][N<span class="number">-1</span>])</span><br></pre></td></tr></table></figure>
<h3 id="Submission-Detail"><a href="#Submission-Detail" class="headerlink" title="Submission Detail"></a>Submission Detail</h3><p>24ms, 92.25%.</p>
<h2 id="Leetcode-931-Minimum-Falling-Path-Sum"><a href="#Leetcode-931-Minimum-Falling-Path-Sum" class="headerlink" title="Leetcode 931 Minimum Falling Path Sum"></a>Leetcode 931 Minimum Falling Path Sum</h2><p><a href="https://leetcode.com/problems/minimum-falling-path-sum/" target="_blank" rel="noopener">原题链接</a></p>
<h3 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h3><p>给定一个matrix, 求从最顶一排(row 0) 到最底一排最便宜的路径. </p>
<p>规则:</p>
<p>A falling path starts at any element in the first row, and chooses one element from each row.  The next row’s choice <strong>must be in a column that is different from the previous row’s column by at most one</strong></p>
<p>比如我在row i时位置是col j, 则我在row i+1时位置只可以选择 col j-1, j, 或者j+1里的一个.</p>
<p>举个例子</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input: [[1,2,3],[4,5,6],[7,8,9]]</span><br><span class="line">Output: 12</span><br><span class="line">Explanation: </span><br><span class="line">The possible falling paths are:</span><br><span class="line">[1,4,7], [1,4,8], [1,5,7], [1,5,8], [1,5,9]</span><br><span class="line">[2,4,7], [2,4,8], [2,5,7], [2,5,8], [2,5,9], [2,6,8], [2,6,9]</span><br><span class="line">[3,5,7], [3,5,8], [3,5,9], [3,6,8], [3,6,9]</span><br><span class="line">The falling path with the smallest sum is [1,4,7], so the answer is 12.</span><br></pre></td></tr></table></figure>
<h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>这题与刷房子给人的感觉极其相似. </p>
<p>首先, 子问题极其明显. </p>
<p>因为我们求到第i排的最便宜路径, 而且明确告诉你了到第N排的选择只有3种, 并且决定于i-1排的时候的选择状态, 所以很明显这里的状态转移方程必然发生在 i与i-1之间. </p>
<p>所以, 可以轻松确定, 子问题就是opt[i-1].</p>
<p>正常情况下, 我们有3种选择(排除了第0列和第N列, 最左最右都只有2条路而不是3条路)</p>
<p>如何到达第i行, 第j列呢? </p>
<p>我们必然是从第 i-1行过来的, 只可能从 j-1, j, j+1这三列里来到第[i, j]格. </p>
<p>所以, 写出递推公式, 就是:</p>
<p>opt[i][j]=min(opt[i-1][j-1], opt[i-1][j], opt[i-1][j+1])+A[i][j] </p>
<p>最后, 再从row N中选择最小的值就可以了.</p>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(self, i, j, opt, A)</span>:</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> j==<span class="number">0</span>:</span><br><span class="line">            opt[i][j]=min(opt[i<span class="number">-1</span>][j], opt[i<span class="number">-1</span>][j+<span class="number">1</span>])+A[i][j]</span><br><span class="line">        <span class="keyword">elif</span> j==len(opt[i])<span class="number">-1</span>:</span><br><span class="line">            opt[i][j]=min(opt[i<span class="number">-1</span>][j<span class="number">-1</span>], opt[i<span class="number">-1</span>][j])+A[i][j]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment">#print(i,j)</span></span><br><span class="line">            opt[i][j]=min(opt[i<span class="number">-1</span>][j<span class="number">-1</span>], opt[i<span class="number">-1</span>][j], opt[i<span class="number">-1</span>][j+<span class="number">1</span>])+A[i][j]</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minFallingPathSum</span><span class="params">(self, A)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type A: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> len(A)==<span class="number">0</span> <span class="keyword">or</span> len(A[<span class="number">0</span>])==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        opt = [[<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> A[<span class="number">0</span>]] <span class="keyword">for</span> j <span class="keyword">in</span> A]</span><br><span class="line">        opt[<span class="number">0</span>]=A[<span class="number">0</span>]</span><br><span class="line">        <span class="comment">#print(opt)</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(A)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>, len(A[<span class="number">0</span>])):</span><br><span class="line">                self.helper(i,j, opt, A)</span><br><span class="line">        <span class="keyword">return</span> min(opt[<span class="number">-1</span>])</span><br></pre></td></tr></table></figure>
<h2 id="Leetcode-276-Paint-Fence"><a href="#Leetcode-276-Paint-Fence" class="headerlink" title="Leetcode 276 Paint Fence"></a>Leetcode 276 Paint Fence</h2><p>Leet上的入门DP问题<br><a href="https://leetcode.com/problems/paint-fence/" target="_blank" rel="noopener">原题链接</a></p>
<h3 id="描述-2"><a href="#描述-2" class="headerlink" title="描述"></a>描述</h3><p>有一排n个桩子，可以给你k种颜色来涂<br>要求不能有连续三个桩子颜色相同。<br>求所有的画法一共有几种</p>
<p>例子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Input: n = 3, k = 2</span><br><span class="line">Output: 6</span><br><span class="line">Explanation: Take c1 as color 1, c2 as color 2. All possible ways are:</span><br><span class="line"></span><br><span class="line">            post1  post2  post3      </span><br><span class="line"> -----      -----  -----  -----       </span><br><span class="line">   1         c1     c1     c2 </span><br><span class="line">   2         c1     c2     c1 </span><br><span class="line">   3         c1     c2     c2 </span><br><span class="line">   4         c2     c1     c1  </span><br><span class="line">   5         c2     c1     c2</span><br><span class="line">   6         c2     c2     c1</span><br></pre></td></tr></table></figure></p>
<h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>上来我居然有点一头雾水, 需要从题目里读取信息.</p>
<p>简单想一下可以发现, 第0位可以有k种画法, 第1位也可以用有k种画法. 两种结合有k*k种画法<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">M[<span class="number">0</span>] = k</span><br><span class="line">M[<span class="number">1</span>] = M[<span class="number">0</span>]*k</span><br></pre></td></tr></table></figure></p>
<p>但从第三位开始, 既然不能连续三个一样, 那画第i个的时候必然<strong>与前两位的信息是有关的</strong></p>
<ol>
<li>这个位置如果<strong>和i-1位颜色相同</strong>, 那必须和i-2位不同,  那就有k-1种选法, 那到i的可能性就是有<code>M[i-2]*(k-1)</code>种画法</li>
<li>这个位置如果<strong>和i-1位不同</strong>, 那就有k-1种选法, 那到i的可能性就是有<code>M[i-1]*(k-1)</code>种画法</li>
</ol>
<p>这两者的可能性是相加的. </p>
<p>所以在第i位一共有那到i的可能性就是有<code>M[i-2]*(k-1) + M[i-1]*(k-1)</code>种画法</p>
<p>一些小点:</p>
<ul>
<li>如果n大于等于3, k小于等于1, 那就没可能符合要求, 回0.</li>
<li>如果n等于0, 回0</li>
<li>如果n==1, 或者(k&lt;=1 且 n&lt;=2), 回k (主要是判断下就不用开M这个array了)</li>
</ul>
<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numWays</span><span class="params">(self, n, k)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        methods = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(n)]</span><br><span class="line">        <span class="keyword">if</span> n==<span class="number">0</span>: </span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> n==<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> k</span><br><span class="line">        <span class="keyword">if</span> k&lt;=<span class="number">1</span> <span class="keyword">and</span> n&lt;=<span class="number">2</span>: </span><br><span class="line">            <span class="keyword">return</span> k</span><br><span class="line">        <span class="keyword">elif</span> k&lt;=<span class="number">1</span>: <span class="comment">#如果n大于3</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        methods[<span class="number">0</span>]=k <span class="comment"># 第一位有k种画法</span></span><br><span class="line">        methods[<span class="number">1</span>]=k*k</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, n):</span><br><span class="line">            methods[i]=methods[i<span class="number">-1</span>]*(k<span class="number">-1</span>)+methods[i<span class="number">-2</span>]*(k<span class="number">-1</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> methods[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>
<h3 id="Submission-Detail-1"><a href="#Submission-Detail-1" class="headerlink" title="Submission Detail"></a>Submission Detail</h3><p>20ms, 97.30%.</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/03/hello-world/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Shirley Hou">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Shirley's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/03/hello-world/" itemprop="url">Hello World</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-12-03T22:06:32+11:00">
                2018-12-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Shirley Hou</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">7</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">3</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">6</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Shirley Hou</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
